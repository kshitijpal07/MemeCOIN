import axios from 'axios';
import * as bs58check from 'bs58check';
import { BeaconEvent } from '../events';
import { TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Origin, BeaconErrorType, SigningType, ColorMode, TransportStatus
// PermissionRequestV3
// RequestEncryptPayloadInput,
// EncryptPayloadResponseOutput,
// EncryptPayloadResponse,
// EncryptPayloadRequest
 } from '@airgap/beacon-types';
import { Client, BeaconError, AppMetadataManager, Serializer, LocalStorage, getAccountIdentifier, getSenderId, Logger, StorageValidator, SDK_VERSION, IndexedDBStorage, MultiTabChannel } from '@airgap/beacon-core';
import { getAddressFromPublicKey, ExposedPromise, generateGUID, toHex, signMessage, CONTRACT_PREFIX, prefixPublicKey, isValidAddress } from '@airgap/beacon-utils';
import { messageEvents } from '../beacon-message-events';
import { TzktBlockExplorer } from '../utils/tzkt-blockexplorer';
import { BeaconEventHandler } from '@airgap/beacon-dapp';
import { DappPostMessageTransport } from '../transports/DappPostMessageTransport';
import { DappP2PTransport } from '../transports/DappP2PTransport';
import { DappWalletConnectTransport } from '../transports/DappWalletConnectTransport';
import { PostMessageTransport } from '@airgap/beacon-transport-postmessage';
import { closeToast, getColorMode, setColorMode, setDesktopList, setExtensionList, setWebList, setiOSList, getiOSList, getDesktopList, getExtensionList, getWebList, isBrowser, isDesktop, isMobileOS, isIOS, currentOS } from '@airgap/beacon-ui';
import { WalletConnectTransport } from '@airgap/beacon-transport-walletconnect';
const logger = new Logger('DAppClient');
/**
 * @publicapi
 *
 * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible
 * wallets and sending requests.
 *
 * @category DApp
 */
export class DAppClient extends Client {
    /**
     * The description of the app
     */
    description;
    /**
     * The block explorer used by the SDK
     */
    blockExplorer;
    /**
     * Automatically switch between apps on Mobile Devices (Enabled by Default)
     */
    enableAppSwitching;
    /**
     * Enable metrics tracking (Disabled by Default)
     */
    enableMetrics;
    userId;
    network;
    events = new BeaconEventHandler();
    postMessageTransport;
    p2pTransport;
    walletConnectTransport;
    wcProjectId;
    wcRelayUrl;
    isGetActiveAccountHandled = false;
    openRequestsOtherTabs = new Set();
    /**
     * A map of requests that are currently "open", meaning we have sent them to a wallet and are still awaiting a response.
     */
    openRequests = new Map();
    /**
     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),
     * the active account is used to determine the network and destination wallet
     */
    _activeAccount = new ExposedPromise();
    /**
     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)
     */
    _activePeer = new ExposedPromise();
    _initPromise;
    isInitPending = false;
    activeAccountLoaded;
    appMetadataManager;
    disclaimerText;
    errorMessages;
    featuredWallets;
    storageValidator;
    bugReportStorage = new IndexedDBStorage('beacon', 'bug_report');
    debounceSetActiveAccount = false;
    multiTabChannel = new MultiTabChannel('beacon-sdk-channel', this.onBCMessageHandler.bind(this), this.onElectedLeaderhandler.bind(this));
    constructor(config) {
        super({
            storage: config && config.storage ? config.storage : new LocalStorage(),
            ...config
        });
        this.description = config.description;
        this.wcProjectId = config.walletConnectOptions?.projectId || '24469fd0a06df227b6e5f7dc7de0ff4f';
        this.wcRelayUrl = config.walletConnectOptions?.relayUrl;
        this.featuredWallets = config.featuredWallets;
        this.events = new BeaconEventHandler(config.eventHandlers, config.disableDefaultEvents ?? false);
        this.blockExplorer = config.blockExplorer ?? new TzktBlockExplorer();
        this.network = config.network ?? { type: config.preferredNetwork ?? NetworkType.MAINNET };
        setColorMode(config.colorMode ?? ColorMode.LIGHT);
        this.disclaimerText = config.disclaimerText;
        this.errorMessages = config.errorMessages ?? {};
        this.appMetadataManager = new AppMetadataManager(this.storage);
        this.storageValidator = new StorageValidator(this.storage);
        this.enableAppSwitching =
            config.enableAppSwitching === undefined ? true : !!config.enableAppSwitching;
        this.enableMetrics = config.enableMetrics ? true : false;
        // Subscribe to storage changes and update the active account if it changes on other tabs
        this.storage.subscribeToStorageChanged(async (event) => {
            if (event.eventType === 'storageCleared') {
                this.setActiveAccount(undefined);
            }
            else if (event.eventType === 'entryModified') {
                if (event.key === this.storage.getPrefixedKey(StorageKey.ACTIVE_ACCOUNT)) {
                    const accountIdentifier = event.newValue;
                    if (!accountIdentifier || accountIdentifier === 'undefined') {
                        this.setActiveAccount(undefined);
                    }
                    else {
                        const account = await this.getAccount(accountIdentifier);
                        this.setActiveAccount(account);
                    }
                }
                else if (event.key === this.storage.getPrefixedKey(StorageKey.ENABLE_METRICS)) {
                    this.enableMetrics = !!(await this.storage.get(StorageKey.ENABLE_METRICS));
                }
            }
        });
        this.activeAccountLoaded = this.storage
            .get(StorageKey.ACTIVE_ACCOUNT)
            .then(async (activeAccountIdentifier) => {
            if (activeAccountIdentifier) {
                const account = await this.accountManager.getAccount(activeAccountIdentifier);
                await this.setActiveAccount(account);
                return account;
            }
            else {
                await this.setActiveAccount(undefined);
                return undefined;
            }
        })
            .catch(async (storageError) => {
            await this.setActiveAccount(undefined);
            logger.error(storageError);
            return undefined;
        });
        this.handleResponse = async (message, connectionInfo) => {
            const typedMessage = message.version === '3'
                ? message.message
                : message;
            const appMetadata = message.version === '3'
                ? typedMessage.blockchainData.appMetadata
                : typedMessage.appMetadata;
            if (this.openRequestsOtherTabs.has(message.id)) {
                this.multiTabChannel.postMessage({
                    type: 'RESPONSE',
                    data: {
                        message,
                        connectionInfo
                    },
                    id: message.id
                });
                if (typedMessage.type !== BeaconMessageType.Acknowledge) {
                    this.openRequestsOtherTabs.delete(message.id);
                }
                return;
            }
            const openRequest = this.openRequests.get(message.id);
            logger.log('### openRequest ###', openRequest);
            logger.log('handleResponse', 'Received message', message, connectionInfo);
            logger.log('### message ###', JSON.stringify(message));
            logger.log('### connectionInfo ###', connectionInfo);
            const handleDisconnect = async () => {
                this.analytics.track('event', 'DAppClient', 'Disconnect received from Wallet');
                const relevantTransport = connectionInfo.origin === Origin.P2P
                    ? this.p2pTransport
                    : connectionInfo.origin === Origin.WALLETCONNECT
                        ? this.walletConnectTransport
                        : this.postMessageTransport ?? (await this.transport);
                if (relevantTransport) {
                    const peers = await relevantTransport.getPeers();
                    const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);
                    if (peer) {
                        await relevantTransport.removePeer(peer);
                    }
                }
                await this.removeAccountsForPeerIds([message.senderId]);
                await this.events.emit(BeaconEvent.CHANNEL_CLOSED);
            };
            if (openRequest && typedMessage.type === BeaconMessageType.Acknowledge) {
                this.analytics.track('event', 'DAppClient', 'Acknowledge received from Wallet');
                logger.log('handleResponse', `acknowledge message received for ${message.id}`);
                this.events
                    .emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {
                    message: typedMessage,
                    extraInfo: {},
                    walletInfo: await this.getWalletInfo()
                })
                    .catch(console.error);
            }
            else if (openRequest) {
                if (typedMessage.type === BeaconMessageType.PermissionResponse && appMetadata) {
                    await this.appMetadataManager.addAppMetadata(appMetadata);
                }
                if (typedMessage.type === BeaconMessageType.Error) {
                    openRequest.reject(typedMessage);
                }
                else {
                    openRequest.resolve({ message, connectionInfo });
                }
                this.openRequests.delete(typedMessage.id);
            }
            else {
                if (typedMessage.type === BeaconMessageType.Disconnect) {
                    await handleDisconnect();
                }
                else if (typedMessage.type === BeaconMessageType.ChangeAccountRequest) {
                    await this.onNewAccount(typedMessage, connectionInfo);
                }
            }
            if (this._transport.isResolved()) {
                const transport = await this.transport;
                if (transport instanceof WalletConnectTransport &&
                    !this.openRequests.has('session_update')) {
                    this.openRequests.set('session_update', new ExposedPromise());
                }
            }
        };
        this.storageValidator
            .validate()
            .then(async (isValid) => {
            const account = await this.activeAccountLoaded;
            if (!isValid) {
                const info = await this.getWalletInfo(undefined, account, false);
                info.type =
                    info.type === 'extension' && account?.origin.type === Origin.P2P ? 'mobile' : info.type;
                await this.storage.set(StorageKey.LAST_SELECTED_WALLET, {
                    icon: info.icon ?? '',
                    key: info.name,
                    type: info.type ?? 'web',
                    name: info.name,
                    url: info.deeplink
                });
                const nowValid = await this.storageValidator.validate();
                if (!nowValid) {
                    this.resetInvalidState(false);
                }
            }
            if (account && account.origin.type !== 'p2p') {
                this.init();
            }
        })
            .catch((err) => logger.error(err.message));
        this.sendMetrics('enable-metrics?' + this.addQueryParam('version', SDK_VERSION), undefined, (res) => {
            if (!res.ok) {
                res.status === 426
                    ? console.error('Metrics are no longer supported for this version, please upgrade.')
                    : console.warn('Network error encountered. Metrics sharing have been automatically disabled.');
            }
            this.enableMetrics = res.ok;
            this.storage.set(StorageKey.ENABLE_METRICS, res.ok);
        }, () => {
            this.enableMetrics = false;
            this.storage.set(StorageKey.ENABLE_METRICS, false);
        });
        this.initUserID().catch((err) => logger.error(err.message));
    }
    async checkIfBCLeaderExists() {
        const hasLeader = await this.multiTabChannel.hasLeader();
        if (hasLeader) {
            return this.multiTabChannel.isLeader();
        }
        await this.multiTabChannel.getLeadership();
        return this.multiTabChannel.isLeader();
    }
    async onElectedLeaderhandler() {
        if (!this._transport.isResolved()) {
            return;
        }
        const tranport = await this.transport;
        if (tranport.type !== TransportType.WALLETCONNECT) {
            return;
        }
        if (tranport.connectionStatus === TransportStatus.CONNECTED) {
            return;
        }
        await tranport.connect();
    }
    async onBCMessageHandler(message) {
        switch (message.type) {
            case BeaconMessageType.PermissionRequest:
            case BeaconMessageType.OperationRequest:
            case BeaconMessageType.SignPayloadRequest:
            case BeaconMessageType.BroadcastRequest:
            case BeaconMessageType.ProofOfEventChallengeRequest:
            case BeaconMessageType.SimulatedProofOfEventChallengeRequest:
                this.prepareRequest(message);
                break;
            case BeaconMessageType.BlockchainRequest:
                this.prepareRequest(message, true);
                break;
            case 'RESPONSE':
                this.handleResponse(message.data.message, message.data.connectionInfo);
                break;
            case 'DISCONNECT':
                this._transport.isResolved() && this.disconnect();
                break;
            default:
                logger.error('onBCMessageHandler', 'message type not recognized', message);
        }
    }
    async prepareRequest(message, isV3 = false) {
        if (!this.multiTabChannel.isLeader()) {
            return;
        }
        // block until the transport is ready
        await this._transport.promise;
        this.openRequestsOtherTabs.add(message.id);
        isV3
            ? this.makeRequestV3(message.data, message.id)
            : this.makeRequest(message.data, false, message.id);
    }
    async createStateSnapshot() {
        if (!localStorage || !this.enableMetrics) {
            return;
        }
        const keys = Object.values(StorageKey).filter((key) => !key.includes('wc@2') && !key.includes('secret') && !key.includes('account'));
        try {
            for (const key of keys) {
                await this.bugReportStorage.set(key, await this.storage.get(key));
            }
        }
        catch (err) {
            logger.error('createStateSnapshot', err.message);
        }
    }
    async initUserID() {
        const id = await this.storage.get(StorageKey.USER_ID);
        if (id) {
            this.userId = id;
            return;
        }
        this.userId = await generateGUID();
        this.storage.set(StorageKey.USER_ID, this.userId);
    }
    async initInternalTransports() {
        const keyPair = await this.keyPair;
        if (this.postMessageTransport || this.p2pTransport || this.walletConnectTransport) {
            return;
        }
        this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);
        await this.addListener(this.postMessageTransport);
        this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
        await this.addListener(this.p2pTransport);
        const wcOptions = {
            projectId: this.wcProjectId,
            relayUrl: this.wcRelayUrl,
            metadata: {
                name: this.name,
                description: this.description ?? '',
                url: this.appUrl ?? '',
                icons: this.iconUrl ? [this.iconUrl] : []
            }
        };
        this.walletConnectTransport = new DappWalletConnectTransport(this.name, keyPair, this.storage, {
            network: this.network.type,
            opts: wcOptions
        }, this.checkIfBCLeaderExists.bind(this));
        this.initEvents();
        await this.addListener(this.walletConnectTransport);
    }
    initEvents() {
        if (!this.walletConnectTransport) {
            return;
        }
        this.walletConnectTransport.setEventHandler("CLOSE_ALERT" /* ClientEvents.CLOSE_ALERT */, this.hideUI.bind(this, ['alert', 'toast']));
        this.walletConnectTransport.setEventHandler("RESET_STATE" /* ClientEvents.RESET_STATE */, this.channelClosedHandler.bind(this));
        this.walletConnectTransport.setEventHandler("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */, this.wcToastHandler.bind(this));
    }
    async wcToastHandler(status) {
        const walletInfo = await (async () => {
            try {
                return await this.getWalletInfo();
            }
            catch {
                return { name: 'wallet' };
            }
        })();
        await this.events.emit(BeaconEvent.HIDE_UI, ['alert']);
        if (status === 'pending') {
            this.events.emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {
                message: {},
                extraInfo: {},
                walletInfo
            });
        }
        else {
            this.events.emit(BeaconEvent.PERMISSION_REQUEST_ERROR, {
                errorResponse: { errorType: BeaconErrorType.ABORTED_ERROR },
                walletInfo
            });
        }
    }
    async channelClosedHandler(type) {
        const transport = await this.transport;
        if (transport.type !== type) {
            return;
        }
        await this.events.emit(BeaconEvent.CHANNEL_CLOSED);
        this.setActiveAccount(undefined);
        await this.disconnect();
    }
    /**
     * Destroy the instance.
     *
     * WARNING: Call `destroy` whenever you no longer need dAppClient
     * as it frees internal subscriptions to the transport and therefore the instance may no longer work properly.
     * If you wish to disconnect your dApp, use `disconnect` instead.
     */
    async destroy() {
        await this.createStateSnapshot();
        await super.destroy();
    }
    async init(transport) {
        if (this._initPromise) {
            return this._initPromise;
        }
        try {
            await this.activeAccountLoaded;
        }
        catch {
            //
        }
        this._initPromise = new Promise(async (resolve) => {
            if (transport) {
                await this.addListener(transport);
                resolve(await super.init(transport));
            }
            else if (this._transport.isSettled()) {
                await (await this.transport).connect();
                resolve(await super.init(await this.transport));
            }
            else {
                const activeAccount = await this.getActiveAccount();
                const stopListening = () => {
                    if (this.postMessageTransport) {
                        this.postMessageTransport.stopListeningForNewPeers().catch(console.error);
                    }
                    if (this.p2pTransport) {
                        this.p2pTransport.stopListeningForNewPeers().catch(console.error);
                    }
                    if (this.walletConnectTransport) {
                        this.walletConnectTransport.stopListeningForNewPeers().catch(console.error);
                    }
                };
                await this.initInternalTransports();
                if (!this.postMessageTransport || !this.p2pTransport || !this.walletConnectTransport) {
                    return;
                }
                this.postMessageTransport.connect().then().catch(console.error);
                if (activeAccount && activeAccount.origin) {
                    const origin = activeAccount.origin.type;
                    // Select the transport that matches the active account
                    if (origin === Origin.EXTENSION) {
                        resolve(await super.init(this.postMessageTransport));
                    }
                    else if (origin === Origin.P2P) {
                        resolve(await super.init(this.p2pTransport));
                    }
                    else if (origin === Origin.WALLETCONNECT) {
                        resolve(await super.init(this.walletConnectTransport));
                    }
                }
                else {
                    const p2pTransport = this.p2pTransport;
                    const postMessageTransport = this.postMessageTransport;
                    const walletConnectTransport = this.walletConnectTransport;
                    postMessageTransport
                        .listenForNewPeer((peer) => {
                        logger.log('init', 'postmessage transport peer connected', peer);
                        this.analytics.track('event', 'DAppClient', 'Extension connected', {
                            peerName: peer.name
                        });
                        this.events
                            .emit(BeaconEvent.PAIR_SUCCESS, peer)
                            .catch((emitError) => console.warn(emitError));
                        this.setActivePeer(peer).catch(console.error);
                        this.setTransport(this.postMessageTransport).catch(console.error);
                        stopListening();
                        resolve(TransportType.POST_MESSAGE);
                    })
                        .catch(console.error);
                    p2pTransport
                        .listenForNewPeer((peer) => {
                        logger.log('init', 'p2p transport peer connected', peer);
                        this.analytics.track('event', 'DAppClient', 'Beacon Wallet connected', {
                            peerName: peer.name
                        });
                        this.events
                            .emit(BeaconEvent.PAIR_SUCCESS, peer)
                            .catch((emitError) => console.warn(emitError));
                        this.setActivePeer(peer).catch(console.error);
                        this.setTransport(this.p2pTransport).catch(console.error);
                        stopListening();
                        resolve(TransportType.P2P);
                    })
                        .catch(console.error);
                    walletConnectTransport
                        .listenForNewPeer((peer) => {
                        logger.log('init', 'walletconnect transport peer connected', peer);
                        this.analytics.track('event', 'DAppClient', 'WalletConnect Wallet connected', {
                            peerName: peer.name
                        });
                        this.events
                            .emit(BeaconEvent.PAIR_SUCCESS, peer)
                            .catch((emitError) => console.warn(emitError));
                        this.setActivePeer(peer).catch(console.error);
                        this.setTransport(this.walletConnectTransport).catch(console.error);
                        stopListening();
                        resolve(TransportType.WALLETCONNECT);
                    })
                        .catch(console.error);
                    PostMessageTransport.getAvailableExtensions()
                        .then(async (extensions) => {
                        this.analytics.track('event', 'DAppClient', 'Extensions detected', { extensions });
                    })
                        .catch((error) => {
                        this._initPromise = undefined;
                        console.error(error);
                    });
                    this.events
                        .emit(BeaconEvent.PAIR_INIT, {
                        p2pPeerInfo: () => {
                            p2pTransport.connect().then().catch(console.error);
                            return p2pTransport.getPairingRequestInfo();
                        },
                        postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),
                        walletConnectPeerInfo: () => walletConnectTransport.getPairingRequestInfo(),
                        networkType: this.network.type,
                        abortedHandler: async () => {
                            logger.log('init', 'ABORTED');
                            this.sendMetrics('performance-metrics/save', await this.buildPayload('connect', 'abort'));
                            await Promise.all([
                                postMessageTransport.disconnect(),
                                // p2pTransport.disconnect(), do not abort connection manually
                                walletConnectTransport.disconnect()
                            ]);
                            this.postMessageTransport =
                                this.walletConnectTransport =
                                    this.p2pTransport =
                                        undefined;
                            this._activeAccount.isResolved() && this.clearActiveAccount();
                            this._initPromise = undefined;
                        },
                        disclaimerText: this.disclaimerText,
                        analytics: this.analytics,
                        featuredWallets: this.featuredWallets
                    })
                        .catch((emitError) => console.warn(emitError));
                }
            }
        });
        return this._initPromise;
    }
    /**
     * Returns the active account
     */
    async getActiveAccount() {
        return this._activeAccount.promise;
    }
    async isInvalidState(account) {
        const activeAccount = await this._activeAccount.promise;
        return !activeAccount
            ? false
            : activeAccount?.address !== account?.address && !this.isGetActiveAccountHandled;
    }
    async resetInvalidState(emit = true) {
        this.accountManager.removeAllAccounts();
        this._activeAccount = ExposedPromise.resolve(undefined);
        this.storage.set(StorageKey.ACTIVE_ACCOUNT, undefined);
        emit && this.events.emit(BeaconEvent.INVALID_ACTIVE_ACCOUNT_STATE);
        !emit && this.hideUI(['alert']);
        await Promise.all([
            this.postMessageTransport?.disconnect(),
            this.walletConnectTransport?.disconnect()
        ]);
        this.postMessageTransport = this.p2pTransport = this.walletConnectTransport = undefined;
        await this.setActivePeer(undefined);
        await this.setTransport(undefined);
        this._initPromise = undefined;
    }
    /**
     * Sets the active account
     *
     * @param account The account that will be set as the active account
     */
    async setActiveAccount(account) {
        if (!this.isGetActiveAccountHandled) {
            console.warn(`An active account has been received, but no active subscription was found for BeaconEvent.ACTIVE_ACCOUNT_SET.
        For more information, visit: https://docs.walletbeacon.io/guides/migration-guide`);
        }
        if (account && this._activeAccount.isSettled() && (await this.isInvalidState(account))) {
            const tranport = await this.transport;
            if (tranport instanceof WalletConnectTransport && tranport.wasDisconnectedByWallet()) {
                await this.resetInvalidState();
                return;
            }
        }
        // when I'm resetting the activeAccount
        if (!account && this._activeAccount.isResolved() && (await this.getActiveAccount())) {
            const transport = await this.transport;
            const activeAccount = await this.getActiveAccount();
            if (!transport || !activeAccount) {
                return;
            }
            if (!this.debounceSetActiveAccount && transport instanceof WalletConnectTransport) {
                this.debounceSetActiveAccount = true;
                this._initPromise = undefined;
                this.postMessageTransport = this.p2pTransport = this.walletConnectTransport = undefined;
                if (this.multiTabChannel.isLeader()) {
                    await transport.disconnect();
                    this.openRequestsOtherTabs.clear();
                }
                else {
                    this.multiTabChannel.postMessage({
                        type: 'DISCONNECT'
                    });
                }
                Array.from(this.openRequests.entries())
                    .filter(([id, _promise]) => id !== 'session_update')
                    .forEach(([id, promise]) => {
                    promise.reject({
                        type: BeaconMessageType.Error,
                        errorType: BeaconErrorType.ABORTED_ERROR,
                        id,
                        senderId: '',
                        version: '2'
                    });
                });
                this.openRequests.clear();
                this.debounceSetActiveAccount = false;
            }
        }
        if (this._activeAccount.isSettled()) {
            // If the promise has already been resolved we need to create a new one.
            this._activeAccount = ExposedPromise.resolve(account);
        }
        else {
            this._activeAccount.resolve(account);
        }
        if (!this.isGetActiveAccountHandled && this._transport.isResolved()) {
            const transport = await this.transport;
            if (transport instanceof WalletConnectTransport && transport.wasDisconnectedByWallet()) {
                await this.resetInvalidState();
                return;
            }
        }
        if (account) {
            const origin = account.origin.type;
            await this.initInternalTransports();
            // Select the transport that matches the active account
            if (origin === Origin.EXTENSION) {
                await this.setTransport(this.postMessageTransport);
            }
            else if (origin === Origin.P2P) {
                await this.setTransport(this.p2pTransport);
            }
            else if (origin === Origin.WALLETCONNECT) {
                await this.setTransport(this.walletConnectTransport);
            }
            if (this._transport.isResolved()) {
                const transport = await this.transport;
                if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {
                    await transport.connect();
                }
            }
            const peer = await this.getPeer(account);
            await this.setActivePeer(peer);
        }
        else {
            await this.setActivePeer(undefined);
            await this.setTransport(undefined);
        }
        await this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);
        await this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);
        return;
    }
    /**
     * Clear the active account
     */
    clearActiveAccount() {
        return this.setActiveAccount();
    }
    async setColorMode(colorMode) {
        return setColorMode(colorMode);
    }
    async getColorMode() {
        return getColorMode();
    }
    /**
     * @deprecated
     *
     * Use getOwnAppMetadata instead
     */
    async getAppMetadata() {
        return this.getOwnAppMetadata();
    }
    async showPrepare() {
        const walletInfo = await (async () => {
            try {
                return await this.getWalletInfo();
            }
            catch {
                return undefined;
            }
        })();
        await this.events.emit(BeaconEvent.SHOW_PREPARE, { walletInfo });
    }
    async hideUI(elements) {
        await this.events.emit(BeaconEvent.HIDE_UI, elements);
    }
    async tryToAppSwitch() {
        if (!isMobileOS(window) || !this.enableAppSwitching) {
            return;
        }
        const wallet = await this.getWalletInfo();
        if (wallet.type !== 'mobile' || !wallet.deeplink) {
            return;
        }
        const link = isIOS(window) ? wallet.deeplink : `${wallet.deeplink}wc?uri=`;
        if (!link?.length) {
            return;
        }
        window.location = link;
    }
    addQueryParam(paramName, paramValue) {
        return paramName + '=' + paramValue;
    }
    async buildPayload(action, status) {
        const wallet = await this.storage.get(StorageKey.LAST_SELECTED_WALLET);
        const transport = this._activeAccount.isResolved()
            ? (await this.getActiveAccount())?.origin.type ?? 'UNKOWN'
            : 'UNKOWN';
        return {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                userId: this.userId,
                os: currentOS(),
                walletName: wallet?.name ?? 'init',
                walletType: wallet?.type ?? 'init',
                sdkVersion: SDK_VERSION,
                transport,
                time: new Date(),
                action,
                status
            })
        };
    }
    sendMetrics(uri, options, thenHandler, catchHandler) {
        if (!this.enableMetrics) {
            return;
        }
        fetch(`https://beacon-backend.prod.gke.papers.tech/${uri}`, options)
            .then((res) => thenHandler && thenHandler(res))
            .catch((err) => {
            console.warn('Network error encountered. Metrics sharing have been automatically disabled.');
            logger.error(err.message);
            this.enableMetrics = false; // in the event of a network error, stop sending metrics
            catchHandler && catchHandler(err);
        });
    }
    async checkMakeRequest() {
        const isResolved = this._transport.isResolved();
        const isWCInstance = isResolved && (await this.transport) instanceof WalletConnectTransport;
        const isLeader = this.multiTabChannel.isLeader();
        return !isResolved || (isResolved && (!isWCInstance || (isWCInstance && isLeader)));
    }
    /**
     * Will remove the account from the local storage and set a new active account if necessary.
     *
     * @param accountIdentifier ID of the account
     */
    async removeAccount(accountIdentifier) {
        const removeAccountResult = super.removeAccount(accountIdentifier);
        const activeAccount = await this.getActiveAccount();
        if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {
            await this.setActiveAccount(undefined);
        }
        return removeAccountResult;
    }
    /**
     * Remove all accounts and set active account to undefined
     */
    async removeAllAccounts() {
        await super.removeAllAccounts();
        await this.setActiveAccount(undefined);
    }
    /**
     * Removes a peer and all the accounts that have been connected through that peer
     *
     * @param peer Peer to be removed
     */
    async removePeer(peer, sendDisconnectToPeer = false) {
        const transport = await this.transport;
        const removePeerResult = transport.removePeer(peer);
        await this.removeAccountsForPeers([peer]);
        if (sendDisconnectToPeer) {
            await this.sendDisconnectToPeer(peer, transport);
        }
        return removePeerResult;
    }
    /**
     * Remove all peers and all accounts that have been connected through those peers
     */
    async removeAllPeers(sendDisconnectToPeers = false) {
        const transport = await this.transport;
        const peers = await transport.getPeers();
        const removePeerResult = transport.removeAllPeers();
        await this.removeAccountsForPeers(peers);
        if (sendDisconnectToPeers) {
            const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer, transport));
            await Promise.all(disconnectPromises);
        }
        return removePeerResult;
    }
    /**
     * Allows the user to subscribe to specific events that are fired in the SDK
     *
     * @param internalEvent The event to subscribe to
     * @param eventCallback The callback that will be called when the event occurs
     */
    async subscribeToEvent(internalEvent, eventCallback) {
        if (internalEvent === BeaconEvent.ACTIVE_ACCOUNT_SET) {
            this.isGetActiveAccountHandled = true;
        }
        await this.events.on(internalEvent, eventCallback);
    }
    /**
     * Check if we have permissions to send the specific message type to the active account.
     * If no active account is set, only permission requests are allowed.
     *
     * @param type The type of the message
     */
    async checkPermissions(type) {
        if ([
            BeaconMessageType.PermissionRequest,
            BeaconMessageType.ProofOfEventChallengeRequest,
            BeaconMessageType.SimulatedProofOfEventChallengeRequest
        ].includes(type)) {
            return true;
        }
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount) {
            throw await this.sendInternalError('No active account set!');
        }
        const permissions = activeAccount.scopes;
        switch (type) {
            case BeaconMessageType.OperationRequest:
                return permissions.includes(PermissionScope.OPERATION_REQUEST);
            case BeaconMessageType.SignPayloadRequest:
                return permissions.includes(PermissionScope.SIGN);
            // TODO: ENCRYPTION
            // case BeaconMessageType.EncryptPayloadRequest:
            //   return permissions.includes(PermissionScope.ENCRYPT)
            case BeaconMessageType.BroadcastRequest:
                return true;
            default:
                return false;
        }
    }
    async sendNotification(title, message, payload, protocolIdentifier) {
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount ||
            (activeAccount &&
                !activeAccount.scopes.includes(PermissionScope.NOTIFICATION) &&
                !activeAccount.notification)) {
            throw new Error('notification permissions not given');
        }
        if (!activeAccount.notification?.token) {
            throw new Error('No AccessToken');
        }
        const url = activeAccount.notification?.apiUrl;
        if (!url) {
            throw new Error('No Push URL set');
        }
        return this.sendNotificationWithAccessToken({
            url,
            recipient: activeAccount.address,
            title,
            body: message,
            payload,
            protocolIdentifier,
            accessToken: activeAccount.notification?.token
        });
    }
    blockchains = new Map();
    addBlockchain(chain) {
        this.blockchains.set(chain.identifier, chain);
        chain.getWalletLists().then((walletLists) => {
            setDesktopList(walletLists.desktopList);
            setExtensionList(walletLists.extensionList);
            setWebList(walletLists.webList);
            setiOSList(walletLists.iOSList);
        });
    }
    removeBlockchain(chainIdentifier) {
        this.blockchains.delete(chainIdentifier);
    }
    async permissionRequest(input) {
        logger.log('permissionRequest', input);
        const blockchain = this.blockchains.get(input.blockchainIdentifier);
        if (!blockchain) {
            throw new Error(`Blockchain "${input.blockchainIdentifier}" not supported by dAppClient`);
        }
        const request = {
            ...input,
            type: BeaconMessageType.PermissionRequest,
            blockchainData: {
                ...input.blockchainData,
                appMetadata: await this.getOwnAppMetadata()
            }
        };
        logger.log('REQUESTION PERMIMISSION V3', 'xxx', request);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('connect', 'start'));
        const logId = `makeRequestV3 ${Date.now()}`;
        logger.time(true, logId);
        const { message: response, connectionInfo } = await this.makeRequestV3(request).catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw new Error('TODO');
            // throw await this.handleRequestError(request, requestError)
        });
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('connect', 'start'));
        logger.log('RESPONSE V3', response, connectionInfo);
        const partialAccountInfos = await blockchain.getAccountInfosFromPermissionResponse(response.message);
        const accountInfo = {
            accountIdentifier: partialAccountInfos[0].accountId,
            senderId: response.senderId,
            origin: {
                type: connectionInfo.origin,
                id: connectionInfo.id
            },
            address: partialAccountInfos[0].address,
            publicKey: partialAccountInfos[0].publicKey,
            scopes: response.message.blockchainData.scopes,
            connectedAt: new Date().getTime(),
            chainData: response.message.blockchainData
        };
        await this.accountManager.addAccount(accountInfo);
        await this.setActiveAccount(accountInfo);
        await blockchain.handleResponse({
            request,
            account: accountInfo,
            output: response,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        await this.notifySuccess(request, {
            account: accountInfo,
            output: {
                address: partialAccountInfos[0].address,
                network: { type: NetworkType.MAINNET },
                scopes: [PermissionScope.OPERATION_REQUEST]
            },
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        // return output
        return response.message;
    }
    async request(input) {
        logger.log('request', input);
        const blockchain = this.blockchains.get(input.blockchainIdentifier);
        if (!blockchain) {
            throw new Error(`Blockchain "${blockchain}" not supported by dAppClient`);
        }
        await blockchain.validateRequest(input);
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount) {
            throw await this.sendInternalError('No active account!');
        }
        const request = {
            ...input,
            type: BeaconMessageType.BlockchainRequest,
            accountId: activeAccount.accountIdentifier
        };
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'start'));
        const logId = `makeRequestV3 ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequestV3(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw new Error(requestError.errorData);
            // throw await this.handleRequestError(request, requestError)
        });
        const { message: response, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'success'));
        await blockchain.handleResponse({
            request,
            account: activeAccount,
            output: response,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        return response.message;
    }
    /**
     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond
     * with an publicKey and permissions that were given. The account returned will be set as the "activeAccount"
     * and will be used for the following requests.
     *
     * @param input The message details we need to prepare the PermissionRequest message.
     */
    async requestPermissions(input) {
        // Add error message for deprecation of network
        // TODO: Remove when we remove deprecated preferredNetwork
        if (input?.network !== undefined && this.network.type !== input?.network?.type) {
            console.error('[BEACON] The network specified in the DAppClient constructor does not match the network set in the permission request. Please set the network in the constructor. Setting it during the Permission Request is deprecated.');
        }
        const request = {
            appMetadata: await this.getOwnAppMetadata(),
            type: BeaconMessageType.PermissionRequest,
            network: this.network,
            scopes: input && input.scopes
                ? input.scopes
                : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]
        };
        this.analytics.track('event', 'DAppClient', 'Permission requested');
        this.sendMetrics('performance-metrics/save', await this.buildPayload('connect', 'start'));
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest()) || !(await this.getActiveAccount())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('connect', 'success'));
        logger.log('requestPermissions', '######## MESSAGE #######');
        logger.log('requestPermissions', message);
        const accountInfo = await this.onNewAccount(message, connectionInfo);
        logger.log('requestPermissions', '######## ACCOUNT INFO #######');
        logger.log('requestPermissions', JSON.stringify(accountInfo));
        await this.accountManager.addAccount(accountInfo);
        const output = {
            ...message,
            walletKey: accountInfo.walletKey,
            address: accountInfo.address,
            accountInfo
        };
        await this.notifySuccess(request, {
            account: accountInfo,
            output,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        this.analytics.track('event', 'DAppClient', 'Permission received', {
            address: accountInfo.address
        });
        return output;
    }
    /**
     * Send a proof of event request to the wallet. The wallet will either accept or decline the challenge.
     * If it is accepted, the challenge will be stored, meaning that even if the user refresh the page, the DAppClient will keep checking if the challenge has been fulfilled.
     * Once the challenge is stored, a challenge stored message will be sent to the wallet.
     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account
     *
     * @param input The message details we need to prepare the ProofOfEventChallenge message.
     */
    async requestProofOfEventChallenge(input) {
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount)
            throw new Error('Please request permissions before doing a proof of event challenge');
        if (activeAccount.walletType !== 'abstracted_account' &&
            activeAccount.verificationType !== 'proof_of_event')
            throw new Error('This wallet is not an abstracted account and thus cannot perform proof of event');
        const request = {
            type: BeaconMessageType.ProofOfEventChallengeRequest,
            contractAddress: activeAccount.address,
            payload: input.payload
        };
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'start'));
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'success'));
        this.analytics.track('event', 'DAppClient', `Proof of event challenge ${message.isAccepted ? 'accepted' : 'refused'}`, { address: activeAccount.address });
        await this.notifySuccess(request, {
            account: activeAccount,
            output: message,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        return message;
    }
    /**
     * Send a simulated proof of event request to the wallet. The wallet will either accept or decline the challenge.
     * It's the same than `requestProofOfEventChallenge` but rather than executing operations on the blockchain to prove the identity,
     * The wallet will return a list of operations that you'll be able to run on your side to verify the identity of the abstracted account
     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account
     *
     * @param input The message details we need to prepare the SimulatedProofOfEventChallenge message.
     */
    async requestSimulatedProofOfEventChallenge(input) {
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount)
            throw new Error('Please request permissions before doing a proof of event challenge');
        if (activeAccount.walletType !== 'abstracted_account' &&
            activeAccount.verificationType !== 'proof_of_event') {
            throw new Error('This wallet is not an abstracted account and thus cannot perform a simulated proof of event');
        }
        const request = {
            type: BeaconMessageType.SimulatedProofOfEventChallengeRequest,
            contractAddress: activeAccount.address,
            ...input
        };
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.analytics.track('event', 'DAppClient', `Simulated proof of event challenge ${!message.errorMessage ? 'accepted' : 'refused'}`, { address: activeAccount.address });
        await this.notifySuccess(request, {
            account: activeAccount,
            output: message,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        return message;
    }
    /**
     * This method will send a "SignPayloadRequest" to the wallet. This method is meant to be used to sign
     * arbitrary data (eg. a string). It will return the signature in the format of "edsig..."
     *
     * @param input The message details we need to prepare the SignPayloadRequest message.
     */
    async requestSignPayload(input) {
        if (!input.payload) {
            throw await this.sendInternalError('Payload must be provided');
        }
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount) {
            throw await this.sendInternalError('No active account!');
        }
        const payload = input.payload;
        if (typeof payload !== 'string') {
            throw new Error('Payload must be a string');
        }
        const signingType = (() => {
            switch (input.signingType) {
                case SigningType.OPERATION:
                    if (!payload.startsWith('03')) {
                        throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');
                    }
                    return SigningType.OPERATION;
                case SigningType.MICHELINE:
                    if (!payload.startsWith('05')) {
                        throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');
                    }
                    return SigningType.MICHELINE;
                case SigningType.RAW:
                default:
                    return SigningType.RAW;
            }
        })();
        this.analytics.track('event', 'DAppClient', 'Signature requested');
        const request = {
            type: BeaconMessageType.SignPayloadRequest,
            signingType,
            payload,
            sourceAddress: input.sourceAddress || activeAccount.address
        };
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'start'));
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'success'));
        await this.notifySuccess(request, {
            account: activeAccount,
            output: message,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        this.analytics.track('event', 'DAppClient', 'Signature response');
        return message;
    }
    /**
     * This method will send an "EncryptPayloadRequest" to the wallet. This method is meant to be used to encrypt or decrypt
     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload
     *
     * @param input The message details we need to prepare the EncryptPayloadRequest message.
     */
    // TODO: ENCRYPTION
    // public async requestEncryptPayload(
    //   input: RequestEncryptPayloadInput
    // ): Promise<EncryptPayloadResponseOutput> {
    //   if (!input.payload) {
    //     throw await this.sendInternalError('Payload must be provided')
    //   }
    //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()
    //   if (!activeAccount) {
    //     throw await this.sendInternalError('No active account!')
    //   }
    //   const payload = input.payload
    //   if (typeof payload !== 'string') {
    //     throw new Error('Payload must be a string')
    //   }
    //   if (typeof input.encryptionCryptoOperation === 'undefined') {
    //     throw new Error('encryptionCryptoOperation must be defined')
    //   }
    //   if (typeof input.encryptionType === 'undefined') {
    //     throw new Error('encryptionType must be defined')
    //   }
    //   const request: EncryptPayloadRequestInput = {
    //     type: BeaconMessageType.EncryptPayloadRequest,
    //     cryptoOperation: input.encryptionCryptoOperation,
    //     encryptionType: input.encryptionType,
    //     payload,
    //     sourceAddress: input.sourceAddress || activeAccount.address
    //   }
    //   const { message, connectionInfo } = await this.makeRequest<
    //     EncryptPayloadRequest,
    //     EncryptPayloadResponse
    //   >(request).catch(async (requestError: ErrorResponse) => {
    //     throw await this.handleRequestError(request, requestError)
    //   })
    //   await this.notifySuccess(request, {
    //     account: activeAccount,
    //     output: message,
    //     connectionContext: connectionInfo,
    //     walletInfo: await this.getWalletInfo()
    //   })
    //   return message
    // }
    /**
     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,
     * eg. transaction or delegation. Not all properties have to be provided. Data like "counter" and fees will be
     * fetched and calculated by the wallet (but they can still be provided if required).
     *
     * @param input The message details we need to prepare the OperationRequest message.
     */
    async requestOperation(input) {
        if (!input.operationDetails) {
            throw await this.sendInternalError('Operation details must be provided');
        }
        const activeAccount = await this.getActiveAccount();
        if (!activeAccount) {
            throw await this.sendInternalError('No active account!');
        }
        const request = {
            type: BeaconMessageType.OperationRequest,
            network: activeAccount.network || this.network,
            operationDetails: input.operationDetails,
            sourceAddress: activeAccount.address || ''
        };
        this.analytics.track('event', 'DAppClient', 'Operation requested');
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'start'));
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'success'));
        await this.notifySuccess(request, {
            account: activeAccount,
            output: message,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        this.analytics.track('event', 'DAppClient', 'Operation response');
        return message;
    }
    /**
     * Sends a "BroadcastRequest" to the wallet. This method can be used to inject an already signed transaction
     * to the network.
     *
     * @param input The message details we need to prepare the BroadcastRequest message.
     */
    async requestBroadcast(input) {
        if (!input.signedTransaction) {
            throw await this.sendInternalError('Signed transaction must be provided');
        }
        // Add error message for deprecation of network
        // TODO: Remove when we remove deprecated preferredNetwork
        if (input.network !== undefined && this.network.type !== input.network?.type) {
            console.error('[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.');
        }
        const request = {
            type: BeaconMessageType.BroadcastRequest,
            network: this.network,
            signedTransaction: input.signedTransaction
        };
        this.analytics.track('event', 'DAppClient', 'Broadcast requested');
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'start'));
        const logId = `makeRequest ${Date.now()}`;
        logger.time(true, logId);
        const res = (await this.checkMakeRequest())
            ? this.makeRequest(request)
            : this.makeRequestBC(request);
        res.catch(async (requestError) => {
            requestError.errorType === BeaconErrorType.ABORTED_ERROR
                ? this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'abort'))
                : this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'error'));
            logger.time(false, logId);
            throw await this.handleRequestError(request, requestError);
        });
        const { message, connectionInfo } = (await res);
        logger.time(false, logId);
        this.sendMetrics('performance-metrics/save', await this.buildPayload('message', 'success'));
        await this.notifySuccess(request, {
            network: this.network,
            output: message,
            blockExplorer: this.blockExplorer,
            connectionContext: connectionInfo,
            walletInfo: await this.getWalletInfo()
        });
        this.analytics.track('event', 'DAppClient', 'Broadcast response');
        return message;
    }
    async setActivePeer(peer) {
        if (this._activePeer.isSettled()) {
            // If the promise has already been resolved we need to create a new one.
            this._activePeer = ExposedPromise.resolve(peer);
        }
        else {
            this._activePeer.resolve(peer);
        }
        if (!peer) {
            return;
        }
        await this.initInternalTransports();
        if (peer.type === 'postmessage-pairing-response') {
            await this.setTransport(this.postMessageTransport);
        }
        else if (peer.type === 'p2p-pairing-response') {
            await this.setTransport(this.p2pTransport);
        }
    }
    /**
     * A "setter" for when the transport needs to be changed.
     */
    async setTransport(transport) {
        if (!transport) {
            this._initPromise = undefined;
        }
        const result = super.setTransport(transport);
        const event = transport ? { ...transport } : undefined;
        // remove keyPair, to prevent dApps from accidentaly leaking the privateKey
        if (event) {
            event.client = {
                ...event.client,
                keyPair: undefined
            };
        }
        await this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, event);
        return result;
    }
    /**
     * This method will emit an internal error message.
     *
     * @param errorMessage The error message to send.
     */
    async sendInternalError(errorMessage) {
        await this.events.emit(BeaconEvent.INTERNAL_ERROR, { text: errorMessage });
        throw new Error(errorMessage);
    }
    /**
     * This method will remove all accounts associated with a specific peer.
     *
     * @param peersToRemove An array of peers for which accounts should be removed
     */
    async removeAccountsForPeers(peersToRemove) {
        const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);
        return this.removeAccountsForPeerIds(peerIdsToRemove);
    }
    async removeAccountsForPeerIds(peerIds) {
        const accounts = await this.accountManager.getAccounts();
        // Remove all accounts with origin of the specified peer
        const accountsToRemove = accounts.filter((account) => peerIds.includes(account.senderId));
        const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);
        await this.accountManager.removeAccounts(accountIdentifiersToRemove);
        // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
        const activeAccount = await this.getActiveAccount();
        if (activeAccount) {
            if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {
                await this.setActiveAccount(undefined);
            }
        }
    }
    /**
     * This message handles errors that we receive from the wallet.
     *
     * @param request The request we sent
     * @param beaconError The error we received
     */
    async handleRequestError(request, beaconError) {
        logger.error('handleRequestError', 'error response', beaconError);
        if (beaconError.errorType) {
            const buttons = [];
            if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {
                const actionCallback = async () => {
                    const operationRequest = request;
                    // if the account we requested is not available, we remove it locally
                    let accountInfo;
                    if (operationRequest.sourceAddress && operationRequest.network) {
                        const accountIdentifier = await getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);
                        accountInfo = await this.getAccount(accountIdentifier);
                        if (accountInfo) {
                            await this.removeAccount(accountInfo.accountIdentifier);
                        }
                    }
                };
                buttons.push({ text: 'Remove account', actionCallback });
            }
            const peer = await this.getPeer();
            const activeAccount = await this.getActiveAccount();
            // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.
            // This most likely means that the user rejected the first permission request after pairing a wallet, so we "forget" the paired wallet to allow the user to pair again.
            if (request.type === BeaconMessageType.PermissionRequest &&
                (await this.getActiveAccount()) === undefined) {
                this._initPromise = undefined;
                this.postMessageTransport = undefined;
                this.p2pTransport = undefined;
                this.walletConnectTransport = undefined;
                await this.setTransport();
                await this.setActivePeer();
            }
            this.events
                .emit(messageEvents[request.type].error, {
                errorResponse: beaconError,
                walletInfo: await this.getWalletInfo(peer, activeAccount),
                errorMessages: this.errorMessages
            }, buttons)
                .catch((emitError) => logger.error('handleRequestError', emitError));
            throw BeaconError.getError(beaconError.errorType, beaconError.errorData);
        }
        throw beaconError;
    }
    /**
     * This message will send an event when we receive a successful response to one of the requests we sent.
     *
     * @param request The request we sent
     * @param response The response we received
     */
    async notifySuccess(request, response) {
        this.events
            .emit(messageEvents[request.type].success, response)
            .catch((emitError) => console.warn(emitError));
    }
    async getWalletInfoFromStorage() {
        return await this.storage.get(StorageKey.LAST_SELECTED_WALLET);
    }
    async updateStorageWallet(walletInfo) {
        const wallet = await this.storage.get(StorageKey.LAST_SELECTED_WALLET);
        if (!wallet) {
            return;
        }
        wallet.name = walletInfo.name;
        wallet.icon = walletInfo.icon ?? wallet.icon;
        this.storage.set(StorageKey.LAST_SELECTED_WALLET, wallet);
    }
    async getWalletInfo(peer, account, readFromStorage = true) {
        const selectedAccount = account ? account : await this.getActiveAccount();
        const selectedPeer = peer ? peer : await this.getPeer(selectedAccount);
        let walletInfo;
        if (selectedAccount) {
            walletInfo = await this.appMetadataManager.getAppMetadata(selectedAccount.senderId);
        }
        let storageWallet;
        if (readFromStorage) {
            storageWallet = await this.getWalletInfoFromStorage();
        }
        if (!walletInfo) {
            walletInfo = {
                name: selectedPeer?.name ?? storageWallet?.key ?? '',
                icon: selectedPeer?.icon ?? storageWallet?.icon,
                type: storageWallet?.type
            };
            this.updateStorageWallet(walletInfo);
        }
        const lowerCaseCompare = (str1, str2) => {
            if (str1 && str2) {
                return str1.toLowerCase() === str2.toLowerCase();
            }
            return false;
        };
        const getOrgName = (name) => name.split(/[_\s]+/)[0];
        const apps = [
            ...getiOSList(),
            ...getWebList(),
            ...getDesktopList(),
            ...getExtensionList()
        ].filter((app) => lowerCaseCompare(getOrgName(app.key), getOrgName(walletInfo?.name ?? 'wallet')));
        // TODO: Remove once all wallets send the icon?
        const mobile = apps.find((app) => app.universalLink || app.key.includes('ios') || app.key.includes('mobile'));
        const browser = apps.find((app) => app.links);
        const desktop = apps.find((app) => app.downloadLink);
        const extension = apps.find((app) => app.id);
        const appTypeMap = {
            extension: { app: extension, type: 'extension' },
            desktop: { app: desktop, type: 'desktop' },
            mobile: { app: mobile, type: 'mobile' },
            web: { app: browser, type: 'web' }
        };
        const defaultType = () => {
            if (isBrowser(window) && browser)
                return { app: browser, type: 'web' };
            if (isDesktop(window) && desktop)
                return { app: desktop, type: 'desktop' };
            if (isBrowser(window) && extension)
                return { app: extension, type: 'extension' };
            if (mobile)
                return { app: mobile, type: 'mobile' };
            return { app: undefined, type: undefined };
        };
        const { app, type } = storageWallet ? appTypeMap[storageWallet.type] : defaultType();
        if (app) {
            let deeplink;
            if (app.hasOwnProperty('links')) {
                deeplink = app.links[selectedAccount?.network.type ?? this.network.type];
            }
            else if (app.hasOwnProperty('deepLink')) {
                deeplink = app.deepLink;
            }
            return {
                name: app?.name ?? walletInfo.name,
                icon: app?.logo ?? walletInfo.icon,
                deeplink,
                type: type
            };
        }
        return walletInfo;
    }
    async getPeer(account) {
        let peer;
        if (account) {
            logger.log('getPeer', 'We have an account', account);
            const postMessagePeers = (await this.postMessageTransport?.getPeers()) ?? [];
            const p2pPeers = (await this.p2pTransport?.getPeers()) ?? [];
            const walletConnectPeers = (await this.walletConnectTransport?.getPeers()) ?? [];
            const peers = [...postMessagePeers, ...p2pPeers, ...walletConnectPeers];
            logger.log('getPeer', 'Found peers', peers, account);
            peer = peers.find((peerEl) => peerEl.senderId === account.senderId);
            if (!peer) {
                // We could not find an exact match for a sender, so we most likely received it over a relay
                peer = peers.find((peerEl) => peerEl.extensionId === account.origin.id);
            }
        }
        else {
            peer = await this._activePeer.promise;
            logger.log('getPeer', 'Active peer', peer);
        }
        return peer;
    }
    async makeRequest(requestInput, skipResponse, otherTabMessageId) {
        const messageId = otherTabMessageId ?? (await generateGUID());
        if (this._initPromise && this.isInitPending) {
            await Promise.all([
                this.postMessageTransport?.disconnect(),
                this.walletConnectTransport?.disconnect()
            ]);
            this._initPromise = undefined;
            this.hideUI(['toast']);
        }
        logger.log('makeRequest', 'starting');
        this.isInitPending = true;
        await this.init();
        this.isInitPending = false;
        logger.log('makeRequest', 'after init');
        if (await this.addRequestAndCheckIfRateLimited()) {
            this.events
                .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                .catch((emitError) => console.warn(emitError));
            throw new Error('rate limit reached');
        }
        if (!(await this.checkPermissions(requestInput.type))) {
            this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));
            throw new Error('No permissions to send this request to wallet!');
        }
        if (!this.beaconId) {
            throw await this.sendInternalError('BeaconID not defined');
        }
        const request = {
            id: messageId,
            version: '2',
            senderId: await getSenderId(await this.beaconId),
            ...requestInput
        };
        let exposed;
        if (!skipResponse) {
            exposed = new ExposedPromise();
            this.addOpenRequest(request.id, exposed);
        }
        const payload = await new Serializer().serialize(request);
        const account = await this.getActiveAccount();
        const peer = await this.getPeer(account);
        const walletInfo = await this.getWalletInfo(peer, account);
        logger.log('makeRequest', 'sending message', request);
        try {
            ;
            (await this.transport).send(payload, peer);
            if (request.type !== BeaconMessageType.PermissionRequest ||
                (this._activeAccount.isResolved() && (await this._activeAccount.promise))) {
                this.tryToAppSwitch();
            }
        }
        catch (sendError) {
            this.events.emit(BeaconEvent.INTERNAL_ERROR, {
                text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                buttons: [
                    {
                        text: 'Reset Connection',
                        actionCallback: async () => {
                            await closeToast();
                            this.disconnect();
                        }
                    }
                ]
            });
            throw sendError;
        }
        if (!otherTabMessageId) {
            this.events
                .emit(messageEvents[requestInput.type].sent, {
                walletInfo: {
                    ...walletInfo,
                    name: walletInfo.name ?? 'Wallet'
                },
                extraInfo: {
                    resetCallback: async () => {
                        this.disconnect();
                    }
                }
            })
                .catch((emitError) => console.warn(emitError));
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return exposed?.promise; // TODO: fix type
    }
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    async makeRequestV3(requestInput, otherTabMessageId) {
        if (this._initPromise && this.isInitPending) {
            await Promise.all([
                this.postMessageTransport?.disconnect(),
                this.walletConnectTransport?.disconnect()
            ]);
            this._initPromise = undefined;
            this.hideUI(['toast']);
        }
        const messageId = otherTabMessageId ?? (await generateGUID());
        logger.log('makeRequest', 'starting');
        this.isInitPending = true;
        await this.init();
        this.isInitPending = false;
        logger.log('makeRequest', 'after init');
        if (await this.addRequestAndCheckIfRateLimited()) {
            this.events
                .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                .catch((emitError) => console.warn(emitError));
            throw new Error('rate limit reached');
        }
        if (!this.beaconId) {
            throw await this.sendInternalError('BeaconID not defined');
        }
        const request = {
            id: messageId,
            version: '3',
            senderId: await getSenderId(await this.beaconId),
            message: requestInput
        };
        const exposed = new ExposedPromise();
        this.addOpenRequest(request.id, exposed);
        const payload = await new Serializer().serialize(request);
        const account = await this.getActiveAccount();
        const peer = await this.getPeer(account);
        const walletInfo = await this.getWalletInfo(peer, account);
        logger.log('makeRequest', 'sending message', request);
        try {
            ;
            (await this.transport).send(payload, peer);
            if (request.message.type !== BeaconMessageType.PermissionRequest ||
                (this._activeAccount.isResolved() && (await this._activeAccount.promise))) {
                this.tryToAppSwitch();
            }
        }
        catch (sendError) {
            this.events.emit(BeaconEvent.INTERNAL_ERROR, {
                text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                buttons: [
                    {
                        text: 'Reset Connection',
                        actionCallback: async () => {
                            await closeToast();
                            this.disconnect();
                        }
                    }
                ]
            });
            throw sendError;
        }
        const index = requestInput.type;
        this.events
            .emit(messageEvents[index].sent, {
            walletInfo: {
                ...walletInfo,
                name: walletInfo.name ?? 'Wallet'
            },
            extraInfo: {
                resetCallback: async () => {
                    this.disconnect();
                }
            }
        })
            .catch((emitError) => console.warn(emitError));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return exposed.promise; // TODO: fix type
    }
    async makeRequestBC(request) {
        if (!this._transport.isResolved()) {
            return;
        }
        const transport = await this.transport;
        if (transport.type !== TransportType.WALLETCONNECT) {
            return;
        }
        if (await this.addRequestAndCheckIfRateLimited()) {
            this.events
                .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                .catch((emitError) => console.warn(emitError));
            throw new Error('rate limit reached');
        }
        const id = await generateGUID();
        this.multiTabChannel.postMessage({
            type: request.type,
            data: request,
            id
        });
        if (request.type !== BeaconMessageType.PermissionRequest ||
            (this._activeAccount.isResolved() && (await this._activeAccount.promise))) {
            this.tryToAppSwitch();
        }
        this.events
            .emit(messageEvents[BeaconMessageType.PermissionRequest].sent, {
            walletInfo: await this.getWalletInfo(),
            extraInfo: {
                resetCallback: () => this.disconnect()
            }
        })
            .catch((emitError) => console.warn(emitError));
        const exposed = new ExposedPromise();
        this.addOpenRequest(id, exposed);
        return exposed.promise;
    }
    async disconnect() {
        if (!this._transport.isResolved()) {
            throw new Error('No transport available.');
        }
        const transport = await this.transport;
        if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {
            throw new Error('Not connected.');
        }
        await this.createStateSnapshot();
        this.sendMetrics('performance-metrics/save', await this.buildPayload('disconnect', 'start'));
        await this.clearActiveAccount();
        if (!(transport instanceof WalletConnectTransport)) {
            await transport.disconnect();
        }
        this.postMessageTransport = undefined;
        this.p2pTransport = undefined;
        this.walletConnectTransport = undefined;
        this.sendMetrics('performance-metrics/save', await this.buildPayload('disconnect', 'success'));
    }
    /**
     * Adds a requests to the "openRequests" set so we know what messages have already been answered/handled.
     *
     * @param id The ID of the message
     * @param promise A promise that resolves once the response for that specific message is received
     */
    addOpenRequest(id, promise) {
        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);
        this.openRequests.set(id, promise);
    }
    async sendNotificationWithAccessToken(notification) {
        const { url, recipient, title, body, payload, protocolIdentifier, accessToken } = notification;
        const timestamp = new Date().toISOString();
        const keypair = await this.keyPair;
        const rawPublicKey = keypair.publicKey;
        const prefix = Buffer.from(new Uint8Array([13, 15, 37, 217]));
        const publicKey = bs58check.encode(Buffer.concat([prefix, Buffer.from(rawPublicKey)]));
        const constructedString = [
            'Tezos Signed Message: ',
            recipient,
            title,
            body,
            timestamp,
            payload
        ].join(' ');
        const bytes = toHex(constructedString);
        const payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
        const signature = await signMessage(payloadBytes, {
            secretKey: Buffer.from(keypair.secretKey)
        });
        const notificationResponse = await axios.post(`${url}/send`, {
            recipient,
            title,
            body,
            timestamp,
            payload,
            accessToken,
            protocolIdentifier,
            sender: {
                name: this.name,
                publicKey,
                signature
            }
        });
        return notificationResponse.data;
    }
    async onNewAccount(message, connectionInfo) {
        // TODO: Migration code. Remove sometime after 1.0.0 release.
        const tempPK = message.publicKey || message.pubkey || message.pubKey;
        const publicKey = !!tempPK ? prefixPublicKey(tempPK) : undefined;
        if (!publicKey && !message.address) {
            throw new Error('PublicKey or Address must be defined');
        }
        const address = message.address ?? (await getAddressFromPublicKey(publicKey));
        if (!isValidAddress(address)) {
            throw new Error(`Invalid address: "${address}"`);
        }
        if (message.walletType === 'abstracted_account' &&
            address.substring(0, 3) !== CONTRACT_PREFIX) {
            throw new Error(`Invalid abstracted account address "${address}", it should be a ${CONTRACT_PREFIX} address`);
        }
        logger.log('######## MESSAGE #######');
        logger.log('onNewAccount', message);
        const walletKey = (await this.storage.get(StorageKey.LAST_SELECTED_WALLET))?.key;
        const accountInfo = {
            accountIdentifier: await getAccountIdentifier(address, message.network),
            senderId: message.senderId,
            origin: {
                type: connectionInfo.origin,
                id: connectionInfo.id
            },
            walletKey,
            address,
            publicKey,
            network: message.network,
            scopes: message.scopes,
            threshold: message.threshold,
            notification: message.notification,
            connectedAt: new Date().getTime(),
            walletType: message.walletType ?? 'implicit',
            verificationType: message.verificationType,
            ...(message.verificationType === 'proof_of_event' ? { hasVerifiedChallenge: false } : {})
        };
        logger.log('accountInfo', '######## ACCOUNT INFO #######');
        logger.log('accountInfo', accountInfo);
        await this.accountManager.addAccount(accountInfo);
        await this.setActiveAccount(accountInfo);
        return accountInfo;
    }
}
//# sourceMappingURL=DAppClient.js.map