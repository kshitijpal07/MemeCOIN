"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectCommunicationClient = exports.PermissionScopeEvents = exports.PermissionScopeMethods = void 0;
const beacon_core_1 = require("@airgap/beacon-core");
const sign_client_1 = require("@walletconnect/sign-client");
const utils_1 = require("@walletconnect/utils");
const error_1 = require("../error");
const beacon_types_1 = require("@airgap/beacon-types");
const beacon_utils_1 = require("@airgap/beacon-utils");
const TEZOS_PLACEHOLDER = 'tezos';
const BEACON_SDK_VERSION = 'beacon_sdk_version';
const logger = new beacon_core_1.Logger('WalletConnectCommunicationClient');
var PermissionScopeMethods;
(function (PermissionScopeMethods) {
    PermissionScopeMethods["GET_ACCOUNTS"] = "tezos_getAccounts";
    PermissionScopeMethods["OPERATION_REQUEST"] = "tezos_send";
    PermissionScopeMethods["SIGN"] = "tezos_sign";
})(PermissionScopeMethods || (exports.PermissionScopeMethods = PermissionScopeMethods = {}));
var PermissionScopeEvents;
(function (PermissionScopeEvents) {
    PermissionScopeEvents["CHAIN_CHANGED"] = "chainChanged";
    PermissionScopeEvents["ACCOUNTS_CHANGED"] = "accountsChanged";
    PermissionScopeEvents["REQUEST_ACKNOWLEDGED"] = "requestAcknowledged";
})(PermissionScopeEvents || (exports.PermissionScopeEvents = PermissionScopeEvents = {}));
function getStringBetween(str, startChar, endChar) {
    if (!str || !startChar || !endChar) {
        return '';
    }
    const startIndex = str.indexOf(startChar);
    const endIndex = str.indexOf(endChar, startIndex + 1);
    if (startIndex === -1 || endIndex === -1) {
        throw new Error('String not found');
    }
    return str.substring(startIndex + 1, endIndex);
}
class WalletConnectCommunicationClient extends beacon_core_1.CommunicationClient {
    constructor(wcOptions, isLeader) {
        super();
        this.wcOptions = wcOptions;
        this.isLeader = isLeader;
        this.activeListeners = new Map();
        this.channelOpeningListeners = new Map();
        this.storage = new beacon_core_1.WCStorage();
        this.disconnectionEvents = new Set();
        /**
         * this queue stores each active message id
         * [0] newest message
         * [length - 1] oldest message
         */
        this.messageIds = [];
    }
    static getInstance(wcOptions, isLeader) {
        if (!this.instance) {
            this.instance = new WalletConnectCommunicationClient(wcOptions, isLeader);
        }
        return WalletConnectCommunicationClient.instance;
    }
    getTopicFromSession(session) {
        return session.topic;
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const callbackFunction = (message) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(message);
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const callbackFunction = (pairingResponse) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(pairingResponse);
            });
            this.channelOpeningListeners.set('channelOpening', callbackFunction);
        });
    }
    clearEvents() {
        var _a, _b, _c, _d, _e, _f;
        (_a = this.signClient) === null || _a === void 0 ? void 0 : _a.removeAllListeners('session_event');
        (_b = this.signClient) === null || _b === void 0 ? void 0 : _b.removeAllListeners('session_update');
        (_c = this.signClient) === null || _c === void 0 ? void 0 : _c.removeAllListeners('session_delete');
        (_d = this.signClient) === null || _d === void 0 ? void 0 : _d.removeAllListeners('session_expire');
        (_e = this.signClient) === null || _e === void 0 ? void 0 : _e.core.pairing.events.removeAllListeners('pairing_delete');
        (_f = this.signClient) === null || _f === void 0 ? void 0 : _f.core.pairing.events.removeAllListeners('pairing_expire');
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            this.activeListeners.clear();
            this.channelOpeningListeners.clear();
        });
    }
    unsubscribeFromEncryptedMessage(_senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // implementation
        });
    }
    closeSignClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.signClient) {
                logger.error('No client active');
                return;
            }
            yield this.signClient.core.relayer.transportClose();
            this.signClient.core.events.removeAllListeners();
            this.signClient.core.relayer.events.removeAllListeners();
            this.signClient.core.heartbeat.stop();
            this.signClient.core.relayer.provider.events.removeAllListeners();
            this.signClient.core.relayer.subscriber.events.removeAllListeners();
            this.signClient.core.relayer.provider.connection.events.removeAllListeners();
            this.clearEvents();
            this.signClient = undefined;
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getSignClient();
            if (!client || !this.session) {
                logger.error('No session available.');
                return;
            }
            client
                .ping({ topic: this.session.topic })
                .then(() => {
                if (this.messageIds.length) {
                    this.acknowledgeRequest(this.messageIds[0]);
                }
            })
                .catch((error) => {
                logger.error(`ping catch handler: ${error.message}`);
            })
                .then(() => {
                clearInterval(this.pingInterval);
                this.pingInterval = undefined;
            });
        });
    }
    checkWalletReadiness(_topic) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pingInterval) {
                return;
            }
            this.ping();
            this.pingInterval = setInterval(() => {
                this.ping();
            }, 30000);
        });
    }
    sendMessage(_message, _peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializer = new beacon_core_1.Serializer();
            const message = (yield serializer.deserialize(_message));
            if (!message) {
                return;
            }
            this.messageIds.unshift(message.id);
            switch (message.type) {
                case beacon_types_1.BeaconMessageType.PermissionRequest:
                    this.requestPermissions(message);
                    break;
                case beacon_types_1.BeaconMessageType.OperationRequest:
                    this.sendOperations(message);
                    break;
                case beacon_types_1.BeaconMessageType.SignPayloadRequest:
                    this.signPayload(message);
                    break;
                default:
                    return;
            }
        });
    }
    fetchAccounts(topic, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            if (!signClient) {
                return;
            }
            return signClient.request({
                topic: topic,
                chainId: chainId,
                request: {
                    method: PermissionScopeMethods.GET_ACCOUNTS,
                    params: {}
                }
            });
        });
    }
    notifyListenersWithPermissionResponse(session, network, sessionEventId) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            let publicKey;
            if (((_a = session.sessionProperties) === null || _a === void 0 ? void 0 : _a.pubkey) &&
                ((_b = session.sessionProperties) === null || _b === void 0 ? void 0 : _b.algo) &&
                ((_c = session.sessionProperties) === null || _c === void 0 ? void 0 : _c.address)) {
                publicKey = (_d = session.sessionProperties) === null || _d === void 0 ? void 0 : _d.pubkey;
                logger.log('[requestPermissions]: Have pubkey in sessionProperties, skipping "get_accounts" call', session.sessionProperties);
            }
            else {
                const accounts = this.getTezosNamespace(session.namespaces).accounts;
                const addressOrPbk = accounts[0].split(':', 3)[2];
                if ((0, beacon_utils_1.isPublicKeySC)(addressOrPbk)) {
                    publicKey = addressOrPbk;
                }
                else {
                    if (network.type !== this.wcOptions.network) {
                        throw new Error('Network in permission request is not the same as preferred network!');
                    }
                    const result = yield this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${network.type}`);
                    if (!result || result.length < 1) {
                        throw new Error('No account shared by wallet');
                    }
                    if (result.some((account) => !account.pubkey)) {
                        throw new Error('Public Key in `tezos_getAccounts` is empty!');
                    }
                    publicKey = (_e = result[0]) === null || _e === void 0 ? void 0 : _e.pubkey;
                }
            }
            if (this.signClient && !this.isLeader() && this.isMobileOS()) {
                yield this.closeSignClient();
            }
            if (!publicKey) {
                throw new Error('Public Key in `tezos_getAccounts` is empty!');
            }
            const permissionResponse = {
                type: beacon_types_1.BeaconMessageType.PermissionResponse,
                appMetadata: {
                    senderId: this.getTopicFromSession(session),
                    name: session.peer.metadata.name,
                    icon: session.peer.metadata.icons[0]
                },
                publicKey,
                network,
                scopes: [beacon_types_1.PermissionScope.SIGN, beacon_types_1.PermissionScope.OPERATION_REQUEST],
                id: (_f = sessionEventId !== null && sessionEventId !== void 0 ? sessionEventId : this.messageIds.pop()) !== null && _f !== void 0 ? _f : '',
                walletType: 'implicit'
            };
            this.notifyListeners(this.getTopicFromSession(session), permissionResponse);
        });
    }
    requestPermissions(message) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('#### Requesting permissions');
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.GET_ACCOUNTS)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.GET_ACCOUNTS);
            }
            if (this.activeAccountOrPbk) {
                try {
                    yield this.openSession();
                }
                catch (error) {
                    logger.error(error.message);
                    return;
                }
            }
            this.setDefaultAccountAndNetwork();
            this.notifyListenersWithPermissionResponse(this.getSession(), message.network);
        });
    }
    /**
     * @description Once the session is establish, send payload to be approved and signed by the wallet.
     * @error MissingRequiredScope is thrown if permission to sign payload was not granted
     */
    signPayload(signPayloadRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            if (!signClient) {
                return;
            }
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.SIGN)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.SIGN);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getAccountOrPK();
            this.validateNetworkAndAccount(network, account);
            this.checkWalletReadiness(this.getTopicFromSession(session));
            // TODO: Type
            signClient
                .request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.SIGN,
                    params: {
                        account: (0, beacon_utils_1.isPublicKeySC)(account) ? yield (0, beacon_utils_1.getAddressFromPublicKey)(account) : account,
                        payload: signPayloadRequest.payload
                    }
                }
            })
                .then((response) => {
                const signPayloadResponse = {
                    type: beacon_types_1.BeaconMessageType.SignPayloadResponse,
                    signingType: signPayloadRequest.signingType,
                    signature: response === null || response === void 0 ? void 0 : response.signature,
                    id: this.messageIds.pop()
                };
                this.notifyListeners(this.getTopicFromSession(session), signPayloadResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.getTopicFromSession(session));
                }
            })
                .catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: beacon_types_1.BeaconMessageType.Error,
                    id: this.messageIds.pop(),
                    errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(this.getTopicFromSession(session), errorResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.getTopicFromSession(session));
                }
            }));
        });
    }
    /**
     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
     * @error MissingRequiredScope is thrown if permission to send operation was not granted
     */
    sendOperations(operationRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            if (!signClient) {
                return;
            }
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.OPERATION_REQUEST)) {
                throw new error_1.MissingRequiredScope(PermissionScopeMethods.OPERATION_REQUEST);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getAccountOrPK();
            this.validateNetworkAndAccount(network, account);
            this.checkWalletReadiness(this.getTopicFromSession(session));
            signClient
                .request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.OPERATION_REQUEST,
                    params: {
                        account: (0, beacon_utils_1.isPublicKeySC)(account) ? yield (0, beacon_utils_1.getAddressFromPublicKey)(account) : account,
                        operations: operationRequest.operationDetails
                    }
                }
            })
                .then((response) => {
                var _a, _b, _c, _d;
                const sendOperationResponse = {
                    type: beacon_types_1.BeaconMessageType.OperationResponse,
                    transactionHash: (_c = (_b = (_a = response.operationHash) !== null && _a !== void 0 ? _a : response.transactionHash) !== null && _b !== void 0 ? _b : response.hash) !== null && _c !== void 0 ? _c : '',
                    id: (_d = this.messageIds.pop()) !== null && _d !== void 0 ? _d : ''
                };
                this.notifyListeners(this.getTopicFromSession(session), sendOperationResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.getTopicFromSession(session));
                }
            })
                .catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: beacon_types_1.BeaconMessageType.Error,
                    id: this.messageIds.pop(),
                    errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(this.getTopicFromSession(session), errorResponse);
                if (this.session && this.messageIds.length) {
                    this.checkWalletReadiness(this.getTopicFromSession(session));
                }
            }));
        });
    }
    isMobileSesion(session) {
        const redirect = session.peer.metadata.redirect;
        return (!!redirect &&
            !!redirect.native &&
            !redirect.native.includes('http') &&
            !redirect.native.includes('ws'));
    }
    /**
     * Function used to fix appSwitching with web wallets when pairing through 'Other wallet flow'
     * @param session the newly created session
     */
    updateStorageWallet(session) {
        var _a;
        const selectedWallet = JSON.parse((_a = localStorage.getItem(beacon_types_1.StorageKey.LAST_SELECTED_WALLET)) !== null && _a !== void 0 ? _a : '{}');
        if (!selectedWallet.key) {
            return;
        }
        if (this.isMobileSesion(session)) {
            selectedWallet.type = 'mobile';
        }
        else {
            selectedWallet.type = 'web';
        }
        localStorage.setItem(beacon_types_1.StorageKey.LAST_SELECTED_WALLET, JSON.stringify(selectedWallet));
    }
    init(forceNewConnection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.warn('init');
            this.disconnectionEvents.size && this.disconnectionEvents.clear();
            if (forceNewConnection) {
                yield this.closePairings();
            }
            const signClient = yield this.getSignClient();
            if (!signClient) {
                throw new Error('Failed to connect to the relayer.');
            }
            const lastIndex = signClient.session.keys.length - 1;
            if (lastIndex > -1) {
                this.session = signClient.session.get(signClient.session.keys[lastIndex]);
                this.updateStorageWallet(this.session);
                this.setDefaultAccountAndNetwork();
                return undefined;
            }
            logger.warn('before create');
            const permissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [],
                methods: [
                    PermissionScopeMethods.GET_ACCOUNTS,
                    PermissionScopeMethods.OPERATION_REQUEST,
                    PermissionScopeMethods.SIGN
                ]
            };
            const optionalPermissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [PermissionScopeEvents.REQUEST_ACKNOWLEDGED],
                methods: []
            };
            const connectParams = {
                requiredNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(permissionScopeParams)
                },
                optionalNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(optionalPermissionScopeParams)
                },
                sessionProperties: {
                    [BEACON_SDK_VERSION]: beacon_core_1.SDK_VERSION
                }
            };
            const { uri, approval } = yield signClient.connect(connectParams).catch((error) => {
                logger.error(`Init error: ${error.message}`);
                localStorage && localStorage.setItem(beacon_types_1.StorageKey.WC_INIT_ERROR, error.message);
                throw new Error(error.message);
            });
            // Extract topic from uri. Format is wc:topic@2...
            const topic = getStringBetween(uri, ':', '@');
            if (!topic) {
                return;
            }
            let hasResponse = false;
            signClient.core.pairing
                .ping({ topic })
                .then(() => __awaiter(this, void 0, void 0, function* () {
                if (!hasResponse) {
                    // Only show "waiting for acknowledge" message if pong arrives before response
                    const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                    fun && fun('pending');
                }
            }))
                .catch((err) => {
                console.error('--------', err);
            });
            approval()
                .then((session) => {
                var _a, _b;
                logger.debug('session open');
                hasResponse = true;
                this.updateStorageWallet(session);
                const pairingResponse = new beacon_types_1.ExtendedWalletConnectPairingResponse(session.topic, session.peer.metadata.name, session.peer.publicKey, '3', session.topic, session.peer.metadata.name);
                this.channelOpeningListeners.forEach((listener) => {
                    listener(pairingResponse);
                });
                if ((session === null || session === void 0 ? void 0 : session.controller) !== ((_a = this.session) === null || _a === void 0 ? void 0 : _a.controller)) {
                    logger.debug('Controller doesnt match, closing active session', [session.pairingTopic]);
                    this.activeAccountOrPbk && this.closeActiveSession(this.activeAccountOrPbk, false);
                    this.session = undefined; // close the previous session
                }
                // We need this check in the event the user aborts the sync process on the wallet side
                // but there is already a connection set
                this.session = (_b = this.session) !== null && _b !== void 0 ? _b : session;
                logger.debug('Session is now', [session.pairingTopic]);
                this.validateReceivedNamespace(permissionScopeParams, this.session.namespaces);
            })
                .catch((error) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                hasResponse = true;
                if (!error.message ||
                    !error.message.length ||
                    error.message.toLowerCase().includes('expir')) {
                    const fun = this.eventHandlers.get("CLOSE_ALERT" /* ClientEvents.CLOSE_ALERT */);
                    fun && fun(beacon_types_1.TransportType.WALLETCONNECT);
                    return;
                }
                logger.error('Error happened!', [error.message]);
                if (this.activeListeners.size === 0) {
                    logger.debug('No active listeners', []);
                    const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                    fun && fun('error');
                }
                else {
                    const _pairingTopic = topic !== null && topic !== void 0 ? topic : (_a = signClient.core.pairing.getPairings()[0]) === null || _a === void 0 ? void 0 : _a.topic;
                    logger.debug('New pairing topic?', []);
                    const errorResponse = {
                        type: beacon_types_1.BeaconMessageType.Error,
                        id: this.messageIds.pop(),
                        errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                    };
                    this.notifyListeners(_pairingTopic, errorResponse);
                }
            }))
                .then(() => __awaiter(this, void 0, void 0, function* () {
                const isLeader = yield this.isLeader();
                if (!isLeader && !this.isMobileOS()) {
                    yield this.closeSignClient();
                }
            }));
            logger.warn('return uri and topic');
            return { uri: uri !== null && uri !== void 0 ? uri : '', topic: topic };
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.storage.backup();
            yield this.closePairings();
            this.unsubscribeFromEncryptedMessages();
            this.messageIds = [];
        });
    }
    subscribeToSessionEvents(signClient) {
        signClient.on('session_event', (event) => {
            if (event.params.event.name === PermissionScopeEvents.REQUEST_ACKNOWLEDGED &&
                this.messageIds.length) {
                this.acknowledgeRequest(this.messageIds[0]);
            }
        });
        signClient.on('session_update', (event) => {
            this.disconnectionEvents.add('session_update');
            const session = signClient.session.get(event.topic);
            if (!session) {
                logger.warn('session_update', 'topic does not exist');
                return;
            }
            this.session = session;
            this.updateActiveAccount(this.getTezosNamespace(event.params.namespaces).accounts, session);
        });
        signClient.on('session_delete', (event) => {
            this.disconnectionEvents.add('session_delete');
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.on('session_expire', (event) => {
            this.disconnectionEvents.add('session_expire');
            this.disconnect(signClient, { type: 'session', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_delete', (event) => {
            this.disconnectionEvents.add('pairing_delete');
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
        signClient.core.pairing.events.on('pairing_expire', (event) => {
            this.disconnectionEvents.add('pairing_expire');
            this.disconnect(signClient, { type: 'pairing', topic: event.topic });
        });
    }
    acknowledgeRequest(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = this.getSession();
            const acknowledgeResponse = {
                type: beacon_types_1.BeaconMessageType.Acknowledge,
                id
            };
            this.notifyListeners(this.getTopicFromSession(session), acknowledgeResponse);
        });
    }
    updateActiveAccount(accounts, session) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (accounts.length) {
                    const [_namespace, chainId, addressOrPbk] = accounts[0].split(':', 3);
                    const session = this.getSession();
                    let publicKey;
                    this.activeNetwork = chainId;
                    this.activeAccountOrPbk = addressOrPbk;
                    if (!(0, beacon_utils_1.isPublicKeySC)(addressOrPbk)) {
                        const token = accounts[1] ? accounts[1].split(':', 3)[2] : '';
                        if ((0, beacon_utils_1.isPublicKeySC)(token)) {
                            publicKey = token;
                        }
                        else {
                            const result = yield this.fetchAccounts(session.topic, `${TEZOS_PLACEHOLDER}:${chainId}`);
                            publicKey = (_a = result === null || result === void 0 ? void 0 : result.find(({ address: _address }) => addressOrPbk === _address)) === null || _a === void 0 ? void 0 : _a.pubkey;
                        }
                    }
                    else {
                        publicKey = addressOrPbk;
                    }
                    if (!publicKey) {
                        throw new Error('Public key for the new account not provided');
                    }
                    this.notifyListeners(this.getTopicFromSession(session), {
                        id: yield (0, beacon_utils_1.generateGUID)(),
                        type: beacon_types_1.BeaconMessageType.ChangeAccountRequest,
                        publicKey,
                        network: { type: chainId },
                        scopes: [beacon_types_1.PermissionScope.SIGN, beacon_types_1.PermissionScope.OPERATION_REQUEST],
                        walletType: 'implicit'
                    });
                }
                else {
                    this.notifyListenersWithPermissionResponse(session, {
                        type: this.wcOptions.network
                    }, 'session_update');
                }
            }
            catch (_b) { }
        });
    }
    disconnect(signClient, trigger) {
        return __awaiter(this, void 0, void 0, function* () {
            let session;
            if (trigger.type === 'session') {
                session = yield this.onSessionClosed(signClient, trigger.topic);
            }
            if (trigger.type === 'pairing') {
                session = yield this.onPairingClosed(signClient, trigger.topic);
            }
            if (!this.activeAccountOrPbk) {
                const fun = this.eventHandlers.get("RESET_STATE" /* ClientEvents.RESET_STATE */);
                fun && fun(beacon_types_1.TransportType.WALLETCONNECT);
            }
            if (!session) {
                return;
            }
            this.notifyListeners(this.getTopicFromSession(session), {
                id: yield (0, beacon_utils_1.generateGUID)(),
                type: beacon_types_1.BeaconMessageType.Disconnect
            });
            this.clearState();
        });
    }
    onPairingClosed(signClient, topic) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const session = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.pairingTopic) === topic
                ? this.session
                : signClient.session
                    .getAll()
                    .find((session) => session.pairingTopic === topic);
            if (!session) {
                return undefined;
            }
            try {
                yield signClient.disconnect({
                    topic: session.topic,
                    reason: {
                        code: -1,
                        message: 'Pairing deleted'
                    }
                });
            }
            catch (error) {
                // If the session was already closed, `disconnect` will throw an error.
                logger.warn(error);
            }
            return session;
        });
    }
    onSessionClosed(signClient, sessionTopic) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session || this.session.topic !== sessionTopic) {
                return undefined;
            }
            try {
                // todo close the matching session and not just the first one
                if (!this.session.pairingTopic) {
                    yield signClient.core.pairing.disconnect({
                        topic: (_a = signClient.core.pairing.getPairings()[0]) === null || _a === void 0 ? void 0 : _a.topic
                    });
                }
                else {
                    yield signClient.core.pairing.disconnect({ topic: this.session.pairingTopic });
                }
            }
            catch (error) {
                // If the pairing was already closed, `disconnect` will throw an error.
                logger.warn(error.message);
            }
            return this.session;
        });
    }
    getPairingRequestInfo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let _uri = '', _topic = '';
            try {
                logger.warn('getPairingRequestInfo');
                const { uri, topic } = (_a = (yield this.init(true))) !== null && _a !== void 0 ? _a : { uri: '', topic: '' };
                _uri = uri;
                _topic = topic;
            }
            catch (error) {
                console.warn(error.message);
            }
            return new beacon_types_1.ExtendedWalletConnectPairingRequest(_topic, 'WalletConnect', yield (0, beacon_utils_1.generateGUID)(), beacon_core_1.BEACON_VERSION, yield (0, beacon_utils_1.generateGUID)(), _uri);
        });
    }
    closePairings() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.closeSessions();
            const signClient = yield this.getSignClient();
            if (signClient) {
                const pairings = (_a = signClient.pairing.getAll()) !== null && _a !== void 0 ? _a : [];
                pairings.length &&
                    (yield Promise.allSettled(pairings.map((pairing) => signClient.disconnect({
                        topic: pairing.topic,
                        reason: {
                            code: 0,
                            message: 'Force new connection'
                        }
                    }))));
            }
            yield this.closeSignClient();
            yield this.storage.resetState();
        });
    }
    closeSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = yield this.getSignClient();
            if (signClient) {
                const sessions = (_a = signClient.session.getAll()) !== null && _a !== void 0 ? _a : [];
                sessions.length &&
                    (yield Promise.allSettled(sessions.map((session) => signClient.disconnect({
                        topic: session.topic,
                        reason: {
                            code: 0,
                            message: 'Force new connection'
                        }
                    }))));
            }
            this.clearState();
        });
    }
    openSession() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const signClient = (yield this.getSignClient());
            const pairingTopic = (_a = signClient.core.pairing.getPairings()[0]) === null || _a === void 0 ? void 0 : _a.topic;
            logger.debug('Starting open session with', [pairingTopic]);
            if (!signClient) {
                throw new Error('Transport error.');
            }
            const permissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [],
                methods: [
                    PermissionScopeMethods.GET_ACCOUNTS,
                    PermissionScopeMethods.OPERATION_REQUEST,
                    PermissionScopeMethods.SIGN
                ]
            };
            const optionalPermissionScopeParams = {
                networks: [this.wcOptions.network],
                events: [PermissionScopeEvents.REQUEST_ACKNOWLEDGED],
                methods: []
            };
            const connectParams = {
                requiredNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(permissionScopeParams)
                },
                optionalNamespaces: {
                    [TEZOS_PLACEHOLDER]: this.permissionScopeParamsToNamespaces(optionalPermissionScopeParams)
                },
                sessionProperties: {
                    [BEACON_SDK_VERSION]: beacon_core_1.SDK_VERSION
                },
                pairingTopic
            };
            logger.debug('Checking wallet readiness', [pairingTopic]);
            this.checkWalletReadiness(pairingTopic);
            try {
                logger.debug('connect', [pairingTopic]);
                const { approval } = yield signClient.connect(connectParams);
                logger.debug('before await approal', [pairingTopic]);
                const session = yield approval();
                logger.debug('after await approal, have session', [pairingTopic]);
                // if I have successfully opened a session and I already have one opened
                if ((session === null || session === void 0 ? void 0 : session.controller) !== ((_b = this.session) === null || _b === void 0 ? void 0 : _b.controller)) {
                    logger.debug('Controller doesnt match, closing active session', [pairingTopic]);
                    this.activeAccountOrPbk && this.closeActiveSession(this.activeAccountOrPbk, false);
                    this.session = undefined; // close the previous session
                }
                // I still need this check in the event the user aborts the sync process on the wallet side
                // but there is already a connection set
                this.session = (_c = this.session) !== null && _c !== void 0 ? _c : session;
                logger.debug('Session is now', [session.pairingTopic, pairingTopic]);
                this.validateReceivedNamespace(permissionScopeParams, this.session.namespaces);
            }
            catch (error) {
                if (!error.message ||
                    !error.message.length ||
                    error.message.toLowerCase().includes('expir')) {
                    const fun = this.eventHandlers.get("CLOSE_ALERT" /* ClientEvents.CLOSE_ALERT */);
                    fun && fun(beacon_types_1.TransportType.WALLETCONNECT);
                }
                else {
                    logger.debug('Error happened!', [pairingTopic]);
                    logger.error(error.message);
                    if (this.activeListeners.size === 0) {
                        logger.debug('No active listeners', [pairingTopic]);
                        const fun = this.eventHandlers.get("WC_ACK_NOTIFICATION" /* ClientEvents.WC_ACK_NOTIFICATION */);
                        fun && fun('error');
                    }
                    else {
                        logger.debug('New pairing topic?', [pairingTopic]);
                        const errorResponse = {
                            type: beacon_types_1.BeaconMessageType.Error,
                            id: this.messageIds.pop(),
                            errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                        };
                        this.notifyListeners(pairingTopic, errorResponse);
                    }
                }
            }
            if (this.session) {
                logger.debug('Have session, returning', [pairingTopic]);
                return this.session;
            }
            else {
                logger.debug('Nope, aborting', [pairingTopic]);
                throw new error_1.InvalidSession('No session set.' + pairingTopic);
            }
        });
    }
    permissionScopeParamsToNamespaces(permissionScopeParams) {
        var _a;
        return {
            chains: permissionScopeParams.networks.map((network) => `${TEZOS_PLACEHOLDER}:${network}`),
            methods: permissionScopeParams.methods,
            events: (_a = permissionScopeParams.events) !== null && _a !== void 0 ? _a : []
        };
    }
    validateReceivedNamespace(scope, receivedNamespaces) {
        if (receivedNamespaces[TEZOS_PLACEHOLDER]) {
            this.validateMethods(scope.methods, receivedNamespaces[TEZOS_PLACEHOLDER].methods);
            if (scope.events) {
                this.validateEvents(scope.events, receivedNamespaces['tezos'].events);
            }
            this.validateAccounts(scope.networks, receivedNamespaces[TEZOS_PLACEHOLDER].accounts);
        }
        else {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All namespaces must be approved', (0, utils_1.getSdkError)('USER_REJECTED').code, 'incomplete', 'tezos');
        }
    }
    validateMethods(requiredMethods, receivedMethods) {
        const missingMethods = [];
        requiredMethods.forEach((method) => {
            if (!receivedMethods.includes(method)) {
                missingMethods.push(method);
            }
        });
        if (missingMethods.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All methods must be approved', (0, utils_1.getSdkError)('USER_REJECTED_METHODS').code, 'incomplete', missingMethods);
        }
    }
    validateEvents(requiredEvents, receivedEvents) {
        const missingEvents = [];
        requiredEvents.forEach((method) => {
            if (!receivedEvents.includes(method)) {
                missingEvents.push(method);
            }
        });
        if (missingEvents.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All events must be approved', (0, utils_1.getSdkError)('USER_REJECTED_EVENTS').code, 'incomplete', missingEvents);
        }
    }
    validateAccounts(requiredNetwork, receivedAccounts) {
        if (receivedAccounts.length === 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must not be empty', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'incomplete');
        }
        const receivedChains = [];
        const invalidChains = [];
        const missingChains = [];
        const invalidChainsNamespace = [];
        receivedAccounts.forEach((chain) => {
            const accountId = chain.split(':');
            if (accountId.length !== 3) {
                invalidChains.push(chain);
            }
            if (accountId[0] !== TEZOS_PLACEHOLDER) {
                invalidChainsNamespace.push(chain);
            }
            const network = accountId[1];
            if (!receivedChains.includes(network)) {
                receivedChains.push(network);
            }
        });
        if (invalidChains.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must be CAIP-10 compliant', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'invalid', invalidChains);
        }
        if (invalidChainsNamespace.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('Accounts must be defined in matching namespace', (0, utils_1.getSdkError)('UNSUPPORTED_ACCOUNTS').code, 'invalid', invalidChainsNamespace);
        }
        requiredNetwork.forEach((network) => {
            if (!receivedChains.includes(network)) {
                missingChains.push(network);
            }
        });
        if (missingChains.length > 0) {
            this.clearState();
            throw new error_1.InvalidReceivedSessionNamespace('All chains must have at least one account', (0, utils_1.getSdkError)('USER_REJECTED_CHAINS').code, 'incomplete', missingChains);
        }
    }
    closeActiveSession(account, notify = true) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.validateNetworkAndAccount(this.getActiveNetwork(), account);
            }
            catch (error) {
                logger.error(error.message);
                return;
            }
            const session = this.getSession();
            if (notify && this.messageIds.length) {
                const errorResponse = {
                    type: beacon_types_1.BeaconMessageType.Disconnect,
                    id: this.messageIds.pop(),
                    errorType: beacon_types_1.BeaconErrorType.ABORTED_ERROR
                };
                this.notifyListeners(this.getTopicFromSession(session), errorResponse);
                this.messageIds = []; // reset
            }
            yield ((_a = this.signClient) === null || _a === void 0 ? void 0 : _a.disconnect({
                topic: session.topic,
                reason: {
                    code: 0,
                    message: 'Force new connection'
                }
            }));
        });
    }
    validateNetworkAndAccount(network, account) {
        if (!this.getTezosNamespace().accounts.includes(`${TEZOS_PLACEHOLDER}:${network}:${account}`)) {
            throw new error_1.InvalidNetworkOrAccount(network, account);
        }
    }
    /**
     * @description Access the active network
     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos networks in the session and none is set as the active one
     */
    getActiveNetwork() {
        if (!this.activeNetwork) {
            this.getSession();
            throw new error_1.ActiveNetworkUnspecified();
        }
        return this.activeNetwork;
    }
    setDefaultAccountAndNetwork() {
        const activeAccount = this.getAccounts();
        if (activeAccount.length) {
            this.activeAccountOrPbk = activeAccount[0];
        }
        const activeNetwork = this.getNetworks();
        if (activeNetwork.length) {
            this.activeNetwork = activeNetwork[0];
        }
    }
    /**
     * @description Return all connected accounts from the active session
     * @error NotConnected if no active session
     */
    getAccounts() {
        return this.getTezosNamespace().accounts.map((account) => account.split(':')[2]);
    }
    /**
     * @description Return all networks from the namespace of the active session
     * @error NotConnected if no active session
     */
    getNetworks() {
        return this.getPermittedNetwork();
    }
    getTezosNamespace(namespaces = this.getSession().namespaces) {
        if (TEZOS_PLACEHOLDER in namespaces) {
            return namespaces[TEZOS_PLACEHOLDER];
        }
        else {
            throw new error_1.InvalidSession('Tezos not found in namespaces');
        }
    }
    getPermittedMethods() {
        return this.getTezosRequiredNamespace().methods;
    }
    getPermittedNetwork() {
        return this.getTezosRequiredNamespace().chains.map((chain) => chain.split(':')[1]);
    }
    getTezosRequiredNamespace() {
        return {
            chains: [`${TEZOS_PLACEHOLDER}:${this.wcOptions.network}`],
            events: [],
            methods: ['tezos_getAccounts', 'tezos_send', 'tezos_sign']
        };
        // if (TEZOS_PLACEHOLDER in this.getSession().requiredNamespaces) {
        //   return this.getSession().requiredNamespaces[TEZOS_PLACEHOLDER] as {
        //     chains: string[]
        //     methods: string[]
        //     events: string[]
        //   }
        // } else {
        //   throw new InvalidSession('Tezos not found in requiredNamespaces')
        // }
    }
    notifyListeners(topic, partialResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = Object.assign(Object.assign({}, partialResponse), { version: '2', senderId: topic });
            const serializer = new beacon_core_1.Serializer();
            const serialized = yield serializer.serialize(response);
            this.activeListeners.forEach((listener) => {
                listener(serialized);
            });
        });
    }
    currentSession() {
        return this.session;
    }
    tryConnectToRelayer() {
        return __awaiter(this, void 0, void 0, function* () {
            const urls = new Set([
                this.wcOptions.opts.relayUrl,
                undefined,
                'wss://relay.walletconnect.com',
                'wss://relay.walletconnect.org'
            ]);
            const errMessages = new Set();
            for (const relayUrl of urls) {
                try {
                    return yield sign_client_1.default.init(Object.assign(Object.assign({}, this.wcOptions.opts), { relayUrl }));
                }
                catch (err) {
                    errMessages.add(err.message);
                    logger.warn(`Failed to connect to ${relayUrl}: ${err.message}`);
                }
            }
            throw new Error(`Failed to connect to relayer: ${Array.from(errMessages).join(',')}`);
        });
    }
    getSignClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signClient === undefined) {
                try {
                    this.signClient = yield this.tryConnectToRelayer();
                    this.subscribeToSessionEvents(this.signClient);
                }
                catch (error) {
                    logger.error(error.message);
                    localStorage && localStorage.setItem(beacon_types_1.StorageKey.WC_INIT_ERROR, error.message);
                    return undefined;
                }
            }
            return this.signClient;
        });
    }
    getSession() {
        if (!this.session) {
            throw new error_1.NotConnected();
        }
        return this.session;
    }
    /**
     * @description Access the public key hash (or public key) of the active account
     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
     */
    getAccountOrPK() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccountOrPbk) {
                this.getSession();
                throw new error_1.ActiveAccountUnspecified();
            }
            return this.activeAccountOrPbk;
        });
    }
    clearState() {
        this.session = undefined;
        this.activeAccountOrPbk = undefined;
        this.activeNetwork = undefined;
    }
}
exports.WalletConnectCommunicationClient = WalletConnectCommunicationClient;
//# sourceMappingURL=WalletConnectCommunicationClient.js.map