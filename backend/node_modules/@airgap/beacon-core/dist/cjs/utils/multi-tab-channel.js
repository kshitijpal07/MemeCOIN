"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiTabChannel = void 0;
const beacon_core_1 = require("@airgap/beacon-core");
const broadcast_channel_1 = require("broadcast-channel");
const logger = new beacon_core_1.Logger('MultiTabChannel');
class MultiTabChannel {
    constructor(name, onBCMessageHandler, onElectedLeaderHandler) {
        this.eventListeners = [
            () => this.onBeforeUnloadHandler(),
            (message) => this.onMessageHandler(message)
        ];
        // Auxiliary variable needed for handling beforeUnload.
        // Closing a tab causes the elector to be killed immediately
        this.wasLeader = false;
        this.onBCMessageHandler = onBCMessageHandler;
        this.onElectedLeaderHandler = onElectedLeaderHandler;
        this.channel = new broadcast_channel_1.BroadcastChannel(name);
        this.elector = (0, broadcast_channel_1.createLeaderElection)(this.channel);
        this.init().then(() => logger.debug('MultiTabChannel', 'constructor', 'init', 'done'));
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const hasLeader = yield this.elector.hasLeader();
            if (!hasLeader) {
                yield this.elector.awaitLeadership();
                this.wasLeader = this.isLeader();
            }
            this.channel.onmessage = this.eventListeners[1];
            window === null || window === void 0 ? void 0 : window.addEventListener('beforeunload', this.eventListeners[0]);
        });
    }
    onBeforeUnloadHandler() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wasLeader) {
                yield this.elector.die();
                this.postMessage({ type: 'LEADER_DEAD' });
            }
            window === null || window === void 0 ? void 0 : window.removeEventListener('beforeunload', this.eventListeners[0]);
            this.channel.removeEventListener('message', this.eventListeners[1]);
        });
    }
    onMessageHandler(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message.type === 'LEADER_DEAD') {
                yield this.elector.awaitLeadership();
                this.wasLeader = this.isLeader();
                if (this.isLeader()) {
                    this.onElectedLeaderHandler();
                }
                return;
            }
            this.onBCMessageHandler(message);
        });
    }
    isLeader() {
        return this.elector.isLeader;
    }
    getLeadership() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.elector.awaitLeadership();
        });
    }
    hasLeader() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.elector.hasLeader();
        });
    }
    postMessage(message) {
        this.channel.postMessage(message);
    }
}
exports.MultiTabChannel = MultiTabChannel;
//# sourceMappingURL=multi-tab-channel.js.map