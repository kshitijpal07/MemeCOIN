"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexedDBStorage = void 0;
const beacon_types_1 = require("@airgap/beacon-types");
const beacon_core_1 = require("@airgap/beacon-core");
const logger = new beacon_core_1.Logger('IndexedDBStorage');
class IndexedDBStorage extends beacon_types_1.Storage {
    constructor(dbName = 'WALLET_CONNECT_V2_INDEXED_DB', storeName = 'keyvaluestorage') {
        super();
        this.dbName = dbName;
        this.storeName = storeName;
        this.db = null;
        this.isSupported = true;
        this.initDB()
            .then((db) => (this.db = db))
            .catch((err) => logger.error(err.message));
    }
    isIndexedDBSupported() {
        if (typeof window !== 'undefined' && 'indexedDB' in window) {
            logger.log('isIndexedDBSupported', 'IndexedDB is supported in this browser.');
            return true;
        }
        else {
            logger.error('isIndexedDBSupported', 'IndexedDB is not supported in this browser.');
            return false;
        }
    }
    initDB() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.isSupported = this.isIndexedDBSupported();
                if (!this.isSupported) {
                    reject('IndexedDB is not supported.');
                }
                const request = indexedDB.open(this.dbName);
                request.onupgradeneeded = (event) => {
                    const request = event.target;
                    const db = request.result;
                    if (!db.objectStoreNames.contains(this.storeName)) {
                        db.createObjectStore(this.storeName);
                    }
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        });
    }
    transaction(mode, operation) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var _a, _b;
                if (!this.isSupported) {
                    reject('IndexedDB is not supported.');
                }
                if (!((_a = this.db) === null || _a === void 0 ? void 0 : _a.objectStoreNames.contains(this.storeName))) {
                    reject(`${this.storeName} not found. error: ${new Error().stack}`);
                }
                const transaction = (_b = this.db) === null || _b === void 0 ? void 0 : _b.transaction(this.storeName, mode);
                const objectStore = transaction === null || transaction === void 0 ? void 0 : transaction.objectStore(this.storeName);
                objectStore && operation(objectStore).then(resolve).catch(reject);
            });
        });
    }
    get(key) {
        return this.transaction('readonly', (store) => new Promise((resolve, reject) => {
            const getRequest = store.get(key);
            getRequest.onsuccess = () => resolve(getRequest.result);
            getRequest.onerror = () => reject(getRequest.error);
        }));
    }
    set(key, value) {
        return this.transaction('readwrite', (store) => new Promise((resolve, reject) => {
            const putRequest = store.put(value, key);
            putRequest.onsuccess = () => resolve();
            putRequest.onerror = () => reject(putRequest.error);
        }));
    }
    delete(key) {
        return this.transaction('readwrite', (store) => new Promise((resolve, reject) => {
            const deleteRequest = store.delete(key);
            deleteRequest.onsuccess = () => resolve();
            deleteRequest.onerror = () => reject(deleteRequest.error);
        }));
    }
    getAll() {
        return this.transaction('readonly', (store) => new Promise((resolve, reject) => {
            const getAllRequest = store.getAll();
            getAllRequest.onsuccess = () => resolve(getAllRequest.result);
            getAllRequest.onerror = () => reject(getAllRequest.error);
        }));
    }
    getAllKeys() {
        return this.transaction('readonly', (store) => new Promise((resolve, reject) => {
            const getAllKeysRequest = store.getAllKeys();
            getAllKeysRequest.onsuccess = () => resolve(getAllKeysRequest.result);
            getAllKeysRequest.onerror = () => reject(getAllKeysRequest.error);
        }));
    }
    clearStore() {
        return this.transaction('readwrite', (store) => new Promise((resolve, reject) => {
            const clearRequest = store.clear();
            clearRequest.onsuccess = () => resolve();
            clearRequest.onerror = () => reject(clearRequest.error);
        }));
    }
    getPrefixedKey(key) {
        logger.debug('getPrefixedKey', key);
        throw new Error('Method not implemented.');
    }
    subscribeToStorageChanged(callback) {
        logger.debug('subscriveToStorageEvent', callback);
        throw new Error('Method not implemented.');
    }
    /**
     * it copies over all key value pairs from a source store into a target one
     * @param targetDBName the name of the target DB
     * @param targetStoreName the name of the target store
     * @param skipKeys all the keys to ignore
     */
    fillStore(targetDBName, targetStoreName, skipKeys = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSupported) {
                logger.error('fillStore', 'IndexedDB not supported.');
                return;
            }
            const targetDBRequest = indexedDB.open(targetDBName);
            targetDBRequest.onerror = (event) => {
                throw new Error(`Failed to open target database: ${event.target.error}`);
            };
            const targetDB = yield new Promise((resolve, reject) => {
                targetDBRequest.onsuccess = (event) => resolve(event.target.result);
                targetDBRequest.onerror = (event) => reject(event.target.error);
            });
            // Copy all items from the source store to the target store, skipping specified keys
            yield this.transaction('readonly', (sourceStore) => __awaiter(this, void 0, void 0, function* () {
                const getAllRequest = sourceStore.getAll();
                const getAllKeysRequest = sourceStore.getAllKeys();
                getAllRequest.onsuccess = () => __awaiter(this, void 0, void 0, function* () {
                    getAllKeysRequest.onsuccess = () => __awaiter(this, void 0, void 0, function* () {
                        const items = getAllRequest.result;
                        const keys = getAllKeysRequest.result;
                        if (!targetDB.objectStoreNames.contains(targetStoreName)) {
                            logger.error(`${this.storeName} not found. ${new Error().stack}`);
                            return;
                        }
                        const targetTransaction = targetDB.transaction(targetStoreName, 'readwrite');
                        const targetStore = targetTransaction.objectStore(targetStoreName);
                        keys
                            .filter((key) => !skipKeys.includes(key.toString()))
                            .forEach((key, index) => {
                            targetStore.put(items[index], key);
                        });
                        targetTransaction.onerror = (event) => {
                            logger.error('Transaction error: ', event.target.error);
                        };
                    });
                });
                getAllKeysRequest.onerror = () => {
                    logger.error('Failed to getAllKeys from source:', getAllKeysRequest.error);
                };
                getAllRequest.onerror = () => {
                    logger.error('Failed to getAll from source:', getAllRequest.error);
                };
            }));
        });
    }
}
exports.IndexedDBStorage = IndexedDBStorage;
//# sourceMappingURL=IndexedDBStorage.js.map